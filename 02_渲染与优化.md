# 二、渲染与优化

> 本章涵盖问题：
> 7. 什么是Overdraw？如何优化？
> 8. Draw Call、Batch、SetPass Call分别是什么？
> 9. 为什么要减少Draw Call？
> 10. 合批方式有哪些？（静态合批、动态合批、SRP Batcher、GPU Instancing）
> 11. 3D物体、粒子和UI之间怎么渲染？渲染顺序是什么？
> 12. URP渲染流程是什么？
> 13. CPU瓶颈和GPU瓶颈如何判断？

---

## 2.1 渲染管线概述

```
┌─────────────────────────────────────────────────────────────────┐
│                    完整渲染管线                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    应用阶段 (CPU)                        │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 1. 场景管理：确定可见物体                        │    │   │
│  │  │ 2. 视锥剔除：剔除相机外的物体                    │    │   │
│  │  │ 3. 遮挡剔���：剔除被遮挡的物体                    │    │   │
│  │  │ 4. 排序：按材质、距离排序                        │    │   │
│  │  │ 5. 设置渲染状态：绑定Shader、纹理、参数          │    │   │
│  │  │ 6. 发送Draw Call                                 │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    几何阶段 (GPU)                        │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 顶点着色器 (Vertex Shader) - 可编程              │    │   │
│  │  │ ├─ 输入：顶点属性（位置、法线、UV等）            │    │   │
│  │  │ ├─ 处理：MVP变换、光照计算、骨骼动画             │    │   │
│  │  │ └─ 输出：裁剪空间坐标、传递给片元的数据          │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                         │                               │   │
│  │                         ▼                               │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 裁剪 (Clipping) - 固定功能                       │    │   │
│  │  │ └─ 裁剪视锥体外的图元                            │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                         │                               │   │
│  │                         ▼                               │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 屏幕映射 (Screen Mapping) - 固定功能             │    │   │
│  │  │ └─ NDC坐标 → 屏幕坐标                            │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    光栅化阶段 (GPU)                      │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 三角形遍历 (Triangle Traversal)                  │    │   │
│  │  │ └─ 确定哪些像素被三角形覆盖，生成片元            │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                         │                               │   │
│  │                         ▼                               │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 片元着色器 (Fragment/Pixel Shader) - 可编程      │    │   │
│  │  │ ├─ 输入：插值后的顶点数据                        │    │   │
│  │  │ ├─ 处理：纹理采样、光照计算、特效                │    │   │
│  │  │ └─ 输出：片元颜色                                │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                         │                               │   │
│  │                         ▼                               │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 逐片元操作 (Per-Fragment Operations)             │    │   │
│  │  │ ├─ 模板测试 (Stencil Test)                       │    │   │
│  │  │ ├─ 深度测试 (Depth Test)                         │    │   │
│  │  │ ├─ 混合 (Blending)                               │    │   │
│  │  │ └─ 写入帧缓冲                                    │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.2 Draw Call、Batch、SetPass Call

```
┌─────────────────────────────────────────────────────────────────┐
│                    渲染调用概念                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Draw Call（绘制调用）                                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • CPU向GPU发送的绘制命令                                │   │
│  │ • 每个Draw Call绘制一个或一批图元                       │   │
│  │ • 包含：顶点数据、索引数据、渲染状态                    │   │
│  │                                                          │   │
│  │ 开销来源：                                               │   │
│  │ • 状态验证和资源绑定                                     │   │
│  │ • 驱动程序转换命令                                       │   │
│  │ • CPU-GPU同步                                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Batch（批次）                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • 合并后的Draw Call                                     │   │
│  │ • 多个物体合并为一次绘制                                │   │
│  │ • Batches = 实际发送给GPU的绘制命令数                   │   │
│  │                                                          │   │
│  │ 合批条件：                                               │   │
│  │ • 相同材质                                               │   │
│  │ • 相同纹理                                               │   │
│  │ • 相同渲染状态                                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  SetPass Call（设置Pass调用）                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • 切换Shader或材质属性的调用                            │   │
│  │ • 比Draw Call开销更大                                   │   │
│  │ • 需要刷新GPU渲染状态                                   │   │
│  │                                                          │   │
│  │ 关系：                                                   │   │
│  │ SetPass Call ≤ Batches ≤ Draw Calls                     │   │
│  │                                                          │   │
│  │ 示例：                                                   │   │
│  │ 10个物体，2种材质                                        │   │
│  │ • 无合批：10 Draw Calls, 2 SetPass Calls                │   │
│  │ • 合批后：2 Batches, 2 SetPass Calls                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 为什么要减少Draw Call？

```
┌─────────────────────────────────────────────────────────────────┐
│                    Draw Call 开销来源                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CPU端开销：                                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. 状态验证                                              │   │
│  │    └─ 检查当前渲染状态是否有效                           │   │
│  │                                                          │   │
│  │ 2. 资源绑定                                              │   │
│  │    ├─ 绑定顶点缓冲区                                     │   │
│  │    ├─ 绑定索引缓冲区                                     │   │
│  │    ├─ 绑定纹理                                           │   │
│  │    ├─ 绑定Shader                                         │   │
│  │    └─ 设置Shader参数                                     │   │
│  │                                                          │   │
│  │ 3. 命令缓冲区                                            │   │
│  │    └─ 将渲染命令写入命令缓冲区                           │   │
│  │                                                          │   │
│  │ 4. 驱动程序开销                                          │   │
│  │    ├─ 驱动程序验证命令                                   │   │
│  │    ├─ 转换为GPU指令                                      │   │
│  │    └─ 提交到GPU命令队列                                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  关键数据：                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • 单次DC的CPU开销约0.1-1ms（取决于复杂度）              │   │
│  │ • SetPass Call（切换Shader）开销更大                    │   │
│  │ • 移动端对DC更敏感（CPU较弱）                           │   │
│  │ • 建议：移动端 < 100-200 DC，PC端 < 1000-2000 DC        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.3 合批方式详解

### 静态合批（Static Batching）

```
┌─────────────────────────────────────────────────────────────────┐
│                    静态合批原理                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  合批前（3个Draw Call）：                                        │
│                                                                 │
│  物体A (Mesh A)          物体B (Mesh B)          物体C (Mesh C) │
│  ┌─────────────┐        ┌─────────────┐        ┌─────────────┐ │
│  │ 顶点: v0-v3 │        │ 顶点: v0-v3 │        │ 顶点: v0-v3 │ │
│  │ 索引: 0,1,2 │        │ 索引: 0,1,2 │        │ 索引: 0,1,2 │ │
│  │ 材质: M     │        │ 材质: M     │        │ 材质: M     │ │
│  └─────────────┘        └─────────────┘        └─────────────┘ │
│        │                       │                       │        │
│        ▼                       ▼                       ▼        │
│   Draw Call 1            Draw Call 2            Draw Call 3    │
│                                                                 │
│  ════════════════════════════════════════════════════════════  │
│                                                                 │
│  合批后（1个Draw Call）：                                        │
│                                                                 │
│  构建时合并为一个大Mesh：                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Combined Mesh                               │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 顶点缓冲区:                                      │    │   │
│  │  │ [A的顶点(已变换)] [B的顶点(已变换)] [C的顶点]    │    │   │
│  │  │  v0 v1 v2 v3      v4 v5 v6 v7      v8 v9 v10 v11 │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 索引缓冲区:                                      │    │   │
│  │  │ [0,1,2,3] [4,5,6,7] [8,9,10,11]                  │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │  材质: M                                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│                        Draw Call 1                              │
│                                                                 │
│  特点：                                                          │
│  • 顶点已预先变换到世界空间（所以不能移动）                      │
│  • 每个物体的顶点都是独立副本（内存增加）                        │
│  • 运行时零CPU开销                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 动态合批（Dynamic Batching）

```
┌─────────────────────────────────────────────────────────────────┐
│                    动态合批原理                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  运行时合并：                                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  每帧执行：                                              │   │
│  │  1. 收集使用相同材质的物体                               │   │
│  │  2. 将顶点变换到世界空间                                 │   │
│  │  3. 合并到临时缓冲区                                     │   │
│  │  4. 提交一次Draw Call                                    │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  限制条件：                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • 顶点数 ≤ 300（Unity 2017之前是900）                   │   │
│  │ • 顶点属性 ≤ 900（位置+法线+UV = 3个属性）              │   │
│  │ • 不能使用多Pass Shader                                 │   │
│  │ • 不能有不同的材质实例（即使是同一材质）                │   │
│  │ • 不能有负缩放                                          │   │
│  │ • 不能使用实时阴影                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  优缺点：                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 优点：                                                   │   │
│  │ • 支持移动物体                                          │   │
│  │ • 不增加内存                                            │   │
│  │                                                          │   │
│  │ 缺点：                                                   │   │
│  │ • 有CPU开销（每帧变换顶点）                             │   │
│  │ • 限制多，很多情况无法合批                              │   │
│  │ • 现代项目中较少使用                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### GPU Instancing

```
┌─────────────────────────────────────────────────────────────────┐
│                    GPU Instancing 原理                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  传统渲染（N个相同物体 = N个Draw Call）：                        │
│                                                                 │
│  for each instance:                                             │
│      SetTransform(instance.transform)                           │
│      DrawMesh(sharedMesh)  // 每次都是一个DC                    │
│                                                                 │
│  ════════════════════════════════════════════════════════════  │
│                                                                 │
│  GPU Instancing（N个相同物体 = 1个Draw Call）：                  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    CPU 端                                │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 实例数据缓冲区 (Instance Buffer)                 │    │   │
│  │  │ ┌─────────────────────────────────────────────┐ │    │   │
│  │  │ │ Instance 0: Transform, Color, ...           │ │    │   │
│  │  │ │ Instance 1: Transform, Color, ...           │ │    │   │
│  │  │ │ Instance 2: Transform, Color, ...           │ │    │   │
│  │  │ │ ...                                         │ │    │   │
│  │  │ │ Instance N: Transform, Color, ...           │ │    │   │
│  │  │ └─────────────────────────────────────────────┘ │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                         │                               │   │
│  │                         ▼                               │   │
│  │  DrawMeshInstanced(mesh, material, instanceBuffer, N)   │   │
│  │  // 只有1个Draw Call！                                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    GPU 端                                │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ 顶点着色器:                                      │    │   │
│  │  │                                                  │    │   │
│  │  │ // 获取当前实例ID                                │    │   │
│  │  │ uint instanceID = SV_InstanceID;                 │    │   │
│  │  │                                                  │    │   │
│  │  │ // 从实例缓冲区读取该实例的变换矩阵              │    │   │
│  │  │ float4x4 transform = instanceBuffer[instanceID]; │    │   │
│  │  │                                                  │    │   │
│  │  │ // 应用变换                                      │    │   │
│  │  │ output.pos = mul(transform, input.pos);          │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  GPU并行处理所有实例，效率极高                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  适用场景：                                                      │
│  • 大量相同网格的物体（草、树、粒子、敌人群）                    │
│  • 每个实例可以有不同的Transform和MaterialPropertyBlock         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### SRP Batcher

```
┌─────────────────────────────────────────────────────────────────┐
│                    SRP Batcher 原理                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  传统渲染：                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 每个物体：                                               │   │
│  │ 1. 设置Shader                                           │   │
│  │ 2. 上传材质属性到GPU                                    │   │
│  │ 3. 上传物体变换到GPU                                    │   │
│  │ 4. Draw Call                                            │   │
│  │                                                          │   │
│  │ 问题：每次都要上传数据，CPU开销大                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  SRP Batcher：                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  持久化缓冲区：                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ Per-Material CBUFFER (持久)                      │    │   │
│  │  │ ┌─────────────────────────────────────────────┐ │    │   │
│  │  │ │ Material 0: _Color, _MainTex_ST, ...        │ │    │   │
│  │  │ │ Material 1: _Color, _MainTex_ST, ...        │ │    │   │
│  │  │ │ ...                                         │ │    │   │
│  │  │ └─────────────────────────────────────────────┘ │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ Per-Object CBUFFER (每帧更新)                    │    │   │
│  │  │ ┌─────────────────────────────────────────────┐ │    │   │
│  │  │ │ Object 0: unity_ObjectToWorld, ...          │ │    │   │
│  │  │ │ Object 1: unity_ObjectToWorld, ...          │ │    │   │
│  │  │ │ ...                                         │ │    │   │
│  │  │ └─────────────────────────────────────────────┘ │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  渲染时：                                                │   │
│  │  1. 只需绑定CBUFFER偏移量                               │   │
│  │  2. 不需要重新上传材质数据                              │   │
│  │  3. 大幅减少CPU开销                                     │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  要求：                                                          │
│  • 使用SRP（URP/HDRP）                                          │
│  • Shader必须兼容SRP Batcher                                    │
│  • 使用CBUFFER_START/CBUFFER_END声明属性                        │
│                                                                 │
│  注意：SRP Batcher不减少Draw Call数量，但减少每个DC的CPU开销    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.4 Overdraw

```
┌─────────────────────────────────────────────────────────────────┐
│                    Overdraw 原理与影响                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  什么是Overdraw？                                                │
│  同一个像素被多次绘制的现象                                      │
│                                                                 │
│  示例场景（俯视图）：                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │     ┌─────────────┐                                     │   │
│  │     │   物体A     │                                     │   │
│  │     │  ┌──────────┼──────┐                              │   │
│  │     │  │  重叠区域 │      │                              │   │
│  │     │  │  (2次绘制)│物体B │                              │   │
│  │     └──┼──────────┘      │                              │   │
│  │        │                 │                              │   │
│  │        └─────────────────┘                              │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Overdraw计算：                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Overdraw = 实际绘制的像素总数 / 屏幕像素数               │   │
│  │                                                          │   │
│  │ 例如：1920×1080屏幕                                      │   │
│  │ - 屏幕像素数 = 2,073,600                                 │   │
│  │ - 如果实际绘制了4,147,200像素                            │   │
│  │ - Overdraw = 4,147,200 / 2,073,600 = 2.0                 │   │
│  │ - 意味着平均每个像素被绘制2次                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  为什么Overdraw影响性能？                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. 填充率限制                                            │   │
│  │    GPU每秒能处理的像素数是有限的（Fill Rate）            │   │
│  │    Overdraw直接消耗填充率                                │   │
│  │                                                          │   │
│  │ 2. 带宽消耗                                              │   │
│  │    每次绘制都需要读写帧缓冲                              │   │
│  │    移动端带宽是瓶颈                                      │   │
│  │                                                          │   │
│  │ 3. 片元着色器执行                                        │   │
│  │    每个像素都要执行片元着色器                            │   │
│  │    复杂Shader + 高Overdraw = 性能灾难                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  半透明物体的Overdraw问题：                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  不透明物体：可以使用Early-Z剔除被遮挡的片元             │   │
│  │  ┌─────┐                                                 │   │
│  │  │ 前  │ ← 绘制                                         │   │
│  │  │     │                                                 │   │
│  │  │ ┌───┼───┐                                             │   │
│  │  │ │后 │   │ ← Early-Z剔除，不执行片元着色器             │   │
│  │  └─┼───┘   │                                             │   │
│  │    └───────┘                                             │   │
│  │                                                          │   │
│  │  半透明物体：必须从后往前绘制，无法Early-Z               │   │
│  │  ┌─────┐                                                 │   │
│  │  │ 前  │ ← 绘制（混合）                                  │   │
│  │  │ α   │                                                 │   │
│  │  │ ┌───┼───┐                                             │   │
│  │  │ │后 │   │ ← 也要绘制（先绘制）                        │   │
│  │  └─┼───┘   │                                             │   │
│  │    └───────┘                                             │   │
│  │  重叠区域绘制2次，无法优化                               │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  优化方法：                                                      │
│  • 减少半透明物体                                               │
│  • 使用Alpha Test代替Alpha Blend（可以Early-Z）                 │
│  • 减少UI层级重叠                                               │
│  • 使用遮挡剔除                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.5 渲染顺序

```
┌─────────────────────────────────────────────────────────────────┐
│                    Unity 渲染顺序                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  渲染队列（Render Queue）：                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  Queue值    名称           说明                          │   │
│  │  ─────────────────────────────────────────────────────  │   │
│  │  0-999      Background     天空盒等背景                  │   │
│  │  1000-1999  Geometry       不透明物体（默认2000）        │   │
│  │  2000-2449  AlphaTest      Alpha测试物体                 │   │
│  │  2450       GeometryLast   最后的不透明物体              │   │
│  │  2500-2999  Transparent    半透明物体（从后往前）        │   │
│  │  3000-3999  Overlay        叠加效果（如镜头光晕）        │   │
│  │  4000+      UI             UGUI（Screen Space）          │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  3D物体、粒子、UI的渲染顺序：                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  1. 不透明3D物体（Geometry队列）                         │   │
│  │     └─ 从前往后排序（减少Overdraw）                      │   │
│  │                                                          │   │
│  │  2. 半透明3D物体（Transparent队列）                      │   │
│  │     └─ 从后往前排序（正确混合）                          │   │
│  │                                                          │   │
│  │  3. 粒子系统                                             │   │
│  │     └─ 通常在Transparent队列                             │   │
│  │     └─ 可以通过Sorting Layer/Order调整                   │   │
│  │                                                          │   │
│  │  4. UI（Screen Space - Overlay）                         │   │
│  │     └─ 最后渲染，覆盖在所有3D物体上                      │   │
│  │     └─ 按Canvas Sort Order排序                           │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  排序层级：                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  1. Camera Depth（相机深度）                             │   │
│  │  2. Sorting Layer（排序层）                              │   │
│  │  3. Order in Layer（层内顺序）                           │   │
│  │  4. Render Queue（渲染队列）                             │   │
│  │  5. 距离排序（同队列内）                                 │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.6 URP渲染流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    URP 渲染流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Setup                                 │   │
│  │  • 设置渲染目标                                          │   │
│  │  • 配置相机参数                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Culling                               │   │
│  │  • 视锥剔除                                              │   │
│  │  • 遮挡剔除（如果启用）                                  │   │
│  │  • 光源剔除                                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Depth Prepass（可选）                 │   │
│  │  • 只写入深度，不写入颜色                                │   │
│  │  • 用于后续的深度测试优化                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Shadow Pass                           │   │
│  │  • 渲染阴影贴图（Shadow Map）                            │   │
│  │  • 主光源阴影                                            │   │
│  │  • 附加光源阴影（如果启用）                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Opaque Pass                           │   │
│  │  • 渲染不透明物体                                        │   │
│  │  • 从前往后排序                                          │   │
│  │  • SRP Batcher优化                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Skybox Pass                           │   │
│  │  • 渲染天空盒                                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Copy Depth（可选）                    │   │
│  │  • 复制深度缓冲供后续使用                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Transparent Pass                      │   │
│  │  • 渲染半透明物体                                        │   │
│  │  • 从后往前排序                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Post Processing                       │   │
│  │  • Bloom、色调映射、抗锯齿等                             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Final Blit                            │   │
│  │  • 输出到屏幕                                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.7 CPU瓶颈 vs GPU瓶颈

```
┌─────────────────────────────────────────────────────────────────┐
│                    瓶颈判断方法                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  使用Profiler判断：                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  CPU瓶颈特征：                                           │   │
│  │  • CPU时间 > GPU时间                                     │   │
│  │  • Profiler中脚本、物理、动画耗时高                      │   │
│  │  • GPU处于等待状态                                       │   │
│  │  • 降低分辨率不影响帧率                                  │   │
│  │                                                          │   │
│  │  GPU瓶颈特征：                                           │   │
│  │  • GPU时间 > CPU时间                                     │   │
│  │  • Profiler中渲染耗时高                                  │   │
│  │  • CPU处于等待状态                                       │   │
│  │  • 降低分辨率帧率提升                                    │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  常见瓶颈原因：                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  CPU瓶颈：                                               │   │
│  │  • Draw Call过多                                         │   │
│  │  • 脚本逻辑复杂                                          │   │
│  │  • 物理计算过多                                          │   │
│  │  • 动画计算过多                                          │   │
│  │  • GC频繁                                                │   │
│  │                                                          │   │
│  │  GPU瓶颈：                                               │   │
│  │  • 填充率不足（Overdraw高）                              │   │
│  │  • Shader复杂                                            │   │
│  │  • 顶点数过多                                            │   │
│  │  • 纹理过大/采样过多                                     │   │
│  │  • 后处理效果过多                                        │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  优化方向：                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  CPU优化：                                               │   │
│  │  • 合批减少Draw Call                                     │   │
│  │  • 优化脚本逻辑                                          │   │
│  │  • 使用Job System多线程                                  │   │
│  │  • 减少GC                                                │   │
│  │                                                          │   │
│  │  GPU优化：                                               │   │
│  │  • 减少Overdraw                                          │   │
│  │  • 简化Shader                                            │   │
│  │  • 使用LOD                                               │   │
│  │  • 压缩纹理                                              │   │
│  │  • 降低分辨率                                            │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 面试要点总结

### 问题7：什么是Overdraw？如何优化？
**答案要点：**
- Overdraw是同一像素被多次绘制的现象
- 消耗填充率和带宽，影响GPU性能
- 优化：减少半透明物体、使用Alpha Test、减少UI层级重叠

### 问题8：Draw Call、Batch、SetPass Call分别是什么？
**答案要点：**
- Draw Call：CPU向GPU发送的绘制命令
- Batch：合并后的Draw Call
- SetPass Call：切换Shader的调用，开销最大
- 关系：SetPass Call ≤ Batches ≤ Draw Calls

### 问题9：为什么要减少Draw Call？
**答案要点：**
- 每个DC都有CPU开销（状态验证、资源绑定、驱动转换）
- 移动端CPU较弱，对DC更敏感
- 建议：移动端<200，PC端<2000

### 问题10：合批方式有哪些？
**答案要点：**
- 静态合批：构建时合并，不能移动，增加内存
- 动态合批：运行时合并，限制多（顶点数≤300）
- GPU Instancing：相同网格一次绘制，GPU并行处理
- SRP Batcher：持久化缓冲区，减少每个DC的CPU开销

### 问题11：3D物体、粒子和UI之间怎么渲染？
**答案要点：**
- 按Render Queue排序：Geometry→Transparent→UI
- 不透明物体从前往后，半透明从后往前
- 粒子通常在Transparent队列
- UI最后渲染（Screen Space - Overlay）

### 问题12：URP渲染流程是什么？
**答案要点：**
- Setup→Culling→Shadow Pass→Opaque Pass→Skybox→Transparent Pass→Post Processing→Final Blit

### 问题13：CPU瓶颈和GPU瓶颈如何判断？
**答案要点：**
- CPU瓶颈：CPU时间>GPU时间，降分辨率不影响帧率
- GPU瓶颈：GPU时间>CPU时间，降分辨率帧率提升
- 使用Profiler分析具体耗时

---

[返回目录](./00_目录.md) | [上一章：GC垃圾回收](./01_GC垃圾回收.md) | [下一章：协程](./03_协程.md)