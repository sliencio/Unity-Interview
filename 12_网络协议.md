# 十二、网络协议

> 本章涵盖问题：
> - TCP和UDP的区别是什么？
> - 游戏中如何选择TCP和UDP？

---

## 12.1 TCP协议

### TCP特点

```
TCP（Transmission Control Protocol）传输控制协议

特点：
┌─────────────────────────────────────────────────────┐
│ 1. 面向连接                                         │
│    └─ 通信前需要建立连接（三次握手）                │
│                                                     │
│ 2. 可靠传输                                         │
│    ├─ 数据不丢失（确认重传机制）                    │
│    ├─ 数据不重复（序列号）                          │
│    └─ 数据有序（按序号重组）                        │
│                                                     │
│ 3. 流量控制                                         │
│    └─ 滑动窗口机制，防止发送过快                    │
│                                                     │
│ 4. 拥塞控制                                         │
│    └─ 慢启动、拥塞避免、快重传、快恢复              │
│                                                     │
│ 5. 全双工通信                                       │
│    └─ 双向同时传输                                  │
└─────────────────────────────────────────────────────┘
```

### 三次握手

```
TCP连接建立（三次握手）：

客户端                                    服务器
   │                                        │
   │ ─────── SYN (seq=x) ─────────────────► │
   │         "我要建立连接"                  │
   │                                        │
   │ ◄────── SYN+ACK (seq=y, ack=x+1) ───── │
   │         "好的，我也准备好了"            │
   │                                        │
   │ ─────── ACK (ack=y+1) ───────────────► │
   │         "收到，开始通信"                │
   │                                        │
   │ ◄═══════════ 数据传输 ═══════════════► │
   │                                        │

为什么是三次？
• 两次：服务器无法确认客户端收到了SYN+ACK
• 三次：双方都确认对方的发送和接收能力
```

### 四次挥手

```
TCP连接断开（四次挥手）：

客户端                                    服务器
   │                                        │
   │ ─────── FIN (seq=u) ─────────────────► │
   │         "我要断开连接"                  │
   │                                        │
   │ ◄────── ACK (ack=u+1) ──────────────── │
   │         "收到，等我处理完"              │
   │                                        │
   │         （服务器继续发送剩余数据）       │
   │                                        │
   │ ◄────── FIN (seq=v) ─────────────────  │
   │         "我也准备好断开了"              │
   │                                        │
   │ ─────── ACK (ack=v+1) ───────────────► │
   │         "好的，再见"                    │
   │                                        │

为什么是四次？
• 全双工通信，双方都需要单独关闭
• 服务器可能还有数据要发送
```

### 可靠传输机制

```
确认重传机制：

发送方                                    接收方
   │                                        │
   │ ─────── Packet 1 (seq=1) ────────────► │
   │                                        │
   │ ◄────── ACK (ack=2) ─────────────────  │
   │                                        │
   │ ─────── Packet 2 (seq=2) ────────────► │
   │                    ✗ 丢失              │
   │                                        │
   │         （超时，重传）                  │
   │                                        │
   │ ─────── Packet 2 (seq=2) ────────────► │
   │                                        │
   │ ◄────── ACK (ack=3) ─────────────────  │
   │                                        │

滑动窗口：
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
  ↑───────────────↑
     发送窗口（可以连续发送，不用等ACK）
```

---

## 12.2 UDP协议

### UDP特点

```
UDP（User Datagram Protocol）用户数据报协议

特点：
┌─────────────────────────────────────────────────────┐
│ 1. 无连接                                           │
│    └─ 直接发送，不需要建立连接                      │
│                                                     │
│ 2. 不可靠                                           │
│    ├─ 可能丢包                                      │
│    ├─ 可能乱序                                      │
│    └─ 可能重复                                      │
│                                                     │
│ 3. 无流量控制                                       │
│    └─ 发送方不管接收方能否处理                      │
│                                                     │
│ 4. 无拥塞控制                                       │
│    └─ 网络拥塞时不会降速                            │
│                                                     │
│ 5. 支持广播和多播                                   │
│    └─ 可以一对多发送                                │
│                                                     │
│ 6. 头部开销小                                       │
│    └─ 只有8字节（TCP是20字节）                      │
└─────────────────────────────────────────────────────┘
```

### UDP数据报结构

```
UDP数据报：

┌─────────────────────────────────────────────────────┐
│                    UDP头部（8字节）                  │
├─────────────────────────────────────────────────────┤
│ 源端口（2字节）    │ 目标端口（2字节）              │
├─────────────────────────────────────────────────────┤
│ 长度（2字节）      │ 校验和（2字节）                │
├─────────────────────────────────────────────────────┤
│                                                     │
│                    数据                             │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## 12.3 TCP vs UDP对比

### 详细对比

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接 | 面向连接 | 无连接 |
| 可靠性 | 可靠 | 不可靠 |
| 顺序 | 保证顺序 | 不保证 |
| 速度 | 较慢 | 较快 |
| 头部大小 | 20字节 | 8字节 |
| 流量控制 | 有 | 无 |
| 拥塞控制 | 有 | 无 |
| 广播/多播 | 不支持 | 支持 |
| 适用场景 | 可靠性要求高 | 实时性要求高 |

### 延迟对比

```
TCP延迟来源：

1. 连接建立：三次握手（1.5 RTT）
2. 确认等待：等待ACK
3. 重传延迟：丢包后等待超时重传
4. 拥塞控制：慢启动阶段速度慢
5. Nagle算法：小包合并发送

UDP延迟：
• 无连接建立延迟
• 无确认等待
• 丢包不重传（应用层处理）
• 发送即到达（或丢失）
```

---

## 12.4 游戏中的选择

### 不同游戏类型的选择

| 游戏类型 | 推荐协议 | 原因 |
|----------|----------|------|
| 回合制游戏 | TCP | 不需要实时，可靠性重要 |
| MMORPG | TCP/UDP混合 | 聊天用TCP，移动用UDP |
| FPS/MOBA | UDP | 实时性要求高 |
| 卡牌游戏 | TCP | 操作必须可靠 |
| 休闲游戏 | TCP | 简单可靠 |

### 混合使用策略

```
典型MMORPG网络架构：

┌─────────────────────────────────────────────────────┐
│                    客户端                           │
├─────────────────────────────────────────────────────┤
│                                                     │
│  TCP连接（可靠通道）          UDP连接（快速通道）   │
│  ├─ 登录认证                  ├─ 位置同步           │
│  ├─ 聊天消息                  ├─ 技能释放           │
│  ├─ 交易操作                  ├─ 状态更新           │
│  ├─ 物品操作                  └─ 实时战斗           │
│  └─ 任务数据                                        │
│                                                     │
└─────────────────────────────────────────────────────┘
                    │                │
                    ▼                ▼
┌─────────────────────────────────────────────────────┐
│                    服务器                           │
└─────────────────────────────────────────────────────┘
```

### 可靠UDP实现

```csharp
// 在UDP上实现可靠传输
public class ReliableUDP
{
    private Dictionary<int, Packet> pendingAcks = new Dictionary<int, Packet>();
    private int sequenceNumber = 0;
    
    // 发送可靠消息
    public void SendReliable(byte[] data)
    {
        var packet = new Packet
        {
            Sequence = sequenceNumber++,
            Data = data,
            SendTime = Time.time,
            Reliable = true
        };
        
        pendingAcks[packet.Sequence] = packet;
        SendPacket(packet);
    }
    
    // 发送不可靠消息
    public void SendUnreliable(byte[] data)
    {
        var packet = new Packet
        {
            Sequence = sequenceNumber++,
            Data = data,
            Reliable = false
        };
        
        SendPacket(packet);
    }
    
    // 处理接收
    public void OnReceive(Packet packet)
    {
        if (packet.IsAck)
        {
            // 收到确认，移除待确认列表
            pendingAcks.Remove(packet.AckSequence);
        }
        else
        {
            // 发送确认
            if (packet.Reliable)
            {
                SendAck(packet.Sequence);
            }
            
            // 处理数据
            ProcessData(packet.Data);
        }
    }
    
    // 重传检查
    public void Update()
    {
        float currentTime = Time.time;
        
        foreach (var kvp in pendingAcks.ToList())
        {
            if (currentTime - kvp.Value.SendTime > RetransmitTimeout)
            {
                // 超时重传
                kvp.Value.SendTime = currentTime;
                SendPacket(kvp.Value);
            }
        }
    }
}
```

### KCP协议

```
KCP：快速可靠的UDP协议

特点：
• 基于UDP实现可靠传输
• 比TCP更快的重传机制
• 可配置的参数

对比TCP：
┌─────────────────────────────────────────────────────┐
│ TCP重传：                                           │
│ • RTO翻倍增长（1s → 2s → 4s）                       │
│ • 等待超时才重传                                    │
│                                                     │
│ KCP重传：                                           │
│ • RTO增长更平缓（1.5倍）                            │
│ • 快速重传（收到后续包立即重传）                    │
│ • 可配置最小RTO                                     │
└─────────────────────────────────────────────────────┘
```

```csharp
// KCP使用示例
using KcpProject;

public class KCPClient
{
    private Kcp kcp;
    private UdpClient udpClient;
    
    public void Initialize()
    {
        udpClient = new UdpClient();
        
        // 创建KCP实例
        kcp = new Kcp(1, (buf, size) =>
        {
            // 发送回调
            udpClient.Send(buf, size);
        });
        
        // 配置参数
        // nodelay: 是否启用nodelay模式
        // interval: 内部更新间隔
        // resend: 快速重传触发次数
        // nc: 是否关闭拥塞控制
        kcp.NoDelay(1, 10, 2, 1);
        
        // 设置窗口大小
        kcp.WndSize(128, 128);
    }
    
    public void Send(byte[] data)
    {
        kcp.Send(data);
    }
    
    public void Update()
    {
        // 接收UDP数据
        if (udpClient.Available > 0)
        {
            var data = udpClient.Receive(ref remoteEP);
            kcp.Input(data);
        }
        
        // 更新KCP
        kcp.Update((uint)DateTime.Now.Ticks);
        
        // 接收KCP数据
        int size = kcp.PeekSize();
        if (size > 0)
        {
            var buffer = new byte[size];
            kcp.Recv(buffer);
            ProcessData(buffer);
        }
    }
}
```

---

## 12.5 网络同步

### 状态同步 vs 帧同步

```
状态同步：
┌─────────────────────────────────────────────────────┐
│ 客户端A                服务器                客户端B│
│    │                     │                     │   │
│    │ ── 操作（移动） ──► │                     │   │
│    │                     │ 计算新状态          │   │
│    │ ◄── 新状态 ──────── │ ── 新状态 ────────► │   │
│    │                     │                     │   │
│ 优点：服务器权威，防作弊                           │
│ 缺点：流量大，延迟敏感                             │
└─────────────────────────────────────────────────────┘

帧同步：
┌─────────────────────────────────────────────────────┐
│ 客户端A                服务器                客户端B│
│    │                     │                     │   │
│    │ ── 操作（输入） ──► │                     │   │
│    │                     │ 收集所有输入        │   │
│    │ ◄── 所有输入 ────── │ ── 所有输入 ──────► │   │
│    │                     │                     │   │
│    │ 本地计算            │            本地计算 │   │
│    │                     │                     │   │
│ 优点：流量小，回放简单                             │
│ 缺点：需要确定性，断线重连慢                       │
└─────────────────────────────────────────────────────┘
```

### 延迟补偿

```csharp
// 客户端预测
public class ClientPrediction
{
    private List<InputState> pendingInputs = new List<InputState>();
    private int lastAckedSequence = 0;
    
    public void Update()
    {
        // 1. 收集输入
        var input = GetInput();
        input.Sequence = nextSequence++;
        
        // 2. 发送到服务器
        SendToServer(input);
        
        // 3. 本地预测执行
        ApplyInput(input);
        pendingInputs.Add(input);
    }
    
    public void OnServerState(ServerState state)
    {
        // 1. 应用服务器状态
        ApplyServerState(state);
        
        // 2. 移除已确认的输入
        pendingInputs.RemoveAll(i => i.Sequence <= state.LastAckedSequence);
        
        // 3. 重新应用未确认的输入（和解）
        foreach (var input in pendingInputs)
        {
            ApplyInput(input);
        }
    }
}
```

---

## 面试要点总结

### 问题71：TCP和UDP的区别是什么？

**答案要点：**

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接 | 面向连接（三次握手） | 无连接 |
| 可靠性 | 可靠（确认重传） | 不可靠 |
| 顺序 | 保证顺序 | 不保证 |
| 速度 | 较慢 | 较快 |
| 头部 | 20字节 | 8字节 |
| 流量/拥塞控制 | 有 | 无 |

### 问题72：游戏中如何选择TCP和UDP？

**答案要点：**

1. **选择TCP的场景**：
   - 回合制游戏
   - 登录、交易等重要操作
   - 聊天系统
   - 可靠性要求高的场景

2. **选择UDP的场景**：
   - FPS、MOBA等实时游戏
   - 位置同步
   - 实时战斗
   - 延迟敏感的场景

3. **混合使用**：
   - 重要数据用TCP
   - 实时数据用UDP
   - 可以在UDP上实现可靠传输（KCP）

4. **可靠UDP方案**：
   - 自己实现确认重传
   - 使用KCP协议
   - 比TCP更快的重传机制

---

[返回目录](./00_目录.md) | [上一章：Lua](./11_Lua.md) | [下一章：数学](./13_数学.md)