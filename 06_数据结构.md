# 六、数据结构

> 本章涵盖问题：
> - List和数组的区别是什么？
> - Dictionary的底层实现原理是什么？
> - HashSet和List的区别是什么？
> - 如何选择合适的数据结构？
> - 常见数据结构的时间复杂度是多少？
> - 二叉树的前中后序遍历是什么？有什么用途？

---

## 6.1 数组（Array）

### 基本特性

```csharp
// 声明和初始化
int[] arr1 = new int[5];                    // 固定大小
int[] arr2 = { 1, 2, 3, 4, 5 };            // 初始化列表
int[] arr3 = new int[] { 1, 2, 3, 4, 5 };  // 显式new
```

### 内存布局

```
数组在内存中连续存储：

int[] arr = { 10, 20, 30, 40, 50 };

内存地址:  0x1000  0x1004  0x1008  0x100C  0x1010
          ┌───────┬───────┬───────┬───────┬───────┐
          │  10   │  20   │  30   │  40   │  50   │
          └───────┴───────┴───────┴───────┴───────┘
          arr[0]  arr[1]  arr[2]  arr[3]  arr[4]

访问arr[i]的地址 = 基地址 + i × 元素大小
arr[2]的地址 = 0x1000 + 2 × 4 = 0x1008
```

### 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 访问 arr[i] | O(1) | 直接计算地址 |
| 修改 arr[i] | O(1) | 直接计算地址 |
| 查找元素 | O(n) | 需要遍历 |
| 插入/删除 | 不支持 | 大小固定 |

---

## 6.2 List\<T\>

### 基本特性

```csharp
List<int> list = new List<int>();
list.Add(1);        // 添加元素
list.Remove(1);     // 删除元素
list.Insert(0, 5);  // 插入元素
int val = list[0];  // 访问元素
```

### 底层实现

```csharp
// List<T>的简化实现
public class List<T>
{
    private T[] _items;      // 内部数组
    private int _size;       // 实际元素数量
    private int _capacity;   // 数组容量
    
    public List()
    {
        _items = Array.Empty<T>();  // 初始为空数组
        _size = 0;
    }
    
    public void Add(T item)
    {
        // 容量不足时扩容
        if (_size == _items.Length)
        {
            EnsureCapacity(_size + 1);
        }
        _items[_size++] = item;
    }
    
    private void EnsureCapacity(int min)
    {
        if (_items.Length < min)
        {
            // 扩容策略：翻倍（至少4）
            int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
            if (newCapacity < min) newCapacity = min;
            
            // 创建新数组并复制
            T[] newItems = new T[newCapacity];
            Array.Copy(_items, newItems, _size);
            _items = newItems;
        }
    }
}
```

### 扩容过程

```
初始状态：capacity=0, size=0
┌─┐
└─┘

Add(1): 扩容到4
┌───┬───┬───┬───┐
│ 1 │   │   │   │  capacity=4, size=1
└───┴───┴───┴───┘

Add(2), Add(3), Add(4):
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │  capacity=4, size=4
└───┴───┴───┴───┘

Add(5): 扩容到8（翻倍）
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │   │   │   │  capacity=8, size=5
└───┴───┴───┴───┴───┴───┴───┴───┘

扩容时会：
1. 分配新数组（产生GC）
2. 复制所有元素（O(n)）
3. 旧数组等待GC回收
```

### 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 访问 list[i] | O(1) | 内部是数组 |
| Add（末尾） | 均摊O(1) | 偶尔扩容O(n) |
| Insert（中间） | O(n) | 需要移动元素 |
| Remove（中间） | O(n) | 需要移动元素 |
| Contains | O(n) | 需要遍历 |
| IndexOf | O(n) | 需要遍历 |

### 优化建议

```csharp
// 1. 预分配容量，避免扩容
List<int> list = new List<int>(1000);  // 预分配1000个元素的空间

// 2. 使用AddRange代替循环Add
list.AddRange(otherList);  // 一次性添加，只扩容一次

// 3. 频繁删除时考虑从后往前删除
for (int i = list.Count - 1; i >= 0; i--)
{
    if (ShouldRemove(list[i]))
        list.RemoveAt(i);  // 从后往前删除，避免移动已处理的元素
}

// 4. 使用RemoveAll代替循环Remove
list.RemoveAll(x => x < 0);  // 一次遍历完成所有删除
```

---

## 6.3 Dictionary\<TKey, TValue\>

### 基本使用

```csharp
Dictionary<string, int> dict = new Dictionary<string, int>();
dict["apple"] = 5;           // 添加/修改
dict.Add("banana", 3);       // 添加（key存在会抛异常）
int val = dict["apple"];     // 访问
bool exists = dict.ContainsKey("apple");  // 检查key
dict.TryGetValue("apple", out int result);  // 安全获取
```

### 底层实现：哈希表

```csharp
// Dictionary的简化实现
public class Dictionary<TKey, TValue>
{
    private struct Entry
    {
        public int hashCode;    // 哈希值
        public int next;        // 链表下一个索引（-1表示结束）
        public TKey key;        // 键
        public TValue value;    // 值
    }
    
    private int[] buckets;      // 桶数组，存储Entry索引
    private Entry[] entries;    // Entry数组
    private int count;          // 元素数量
    private int freeList;       // 空闲链表头
}
```

### 哈希表工作原理

```
添加 dict["apple"] = 5:

1. 计算哈希值
   hashCode = "apple".GetHashCode() = 123456789

2. 计算桶索引
   bucketIndex = hashCode % buckets.Length = 123456789 % 8 = 5

3. 存储到Entry数组，并链接到桶
   
buckets数组:
┌───┬───┬───┬───┬───┬───┬───┬───┐
│-1 │-1 │-1 │-1 │-1 │ 0 │-1 │-1 │  buckets[5] = 0（指向entries[0]）
└───┴───┴───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5   6   7

entries数组:
┌─────────────────────────────────────┐
│ [0] hashCode=123456789              │
│     next=-1                         │
│     key="apple"                     │
│     value=5                         │
└─────────────────────────────────────┘
```

### 哈希冲突处理（链地址法）

```
添加 dict["banana"] = 3，假设也落在桶5（冲突）:

buckets数组:
┌───┬───┬───┬───┬───┬───┬───┬───┐
│-1 │-1 │-1 │-1 │-1 │ 1 │-1 │-1 │  buckets[5] = 1（指向最新的entries[1]）
└───┴───┴───┴───┴───┴───┴───┴───┘

entries数组:
┌─────────────────────────────────────┐
│ [0] hashCode=123456789              │
│     next=-1                         │  ← 链表尾
│     key="apple"                     │
│     value=5                         │
├─────────────────────────────────────┤
│ [1] hashCode=987654321              │
│     next=0                          │  ← 指向entries[0]
│     key="banana"                    │
│     value=3                         │
└─────────────────────────────────────┘

查找 dict["apple"]:
1. 计算hashCode和bucketIndex=5
2. 从buckets[5]=1开始遍历链表
3. entries[1].key="banana" ≠ "apple"，继续
4. entries[0].key="apple" = "apple"，找到！
```

### 时间复杂度

| 操作 | 平均 | 最坏 | 说明 |
|------|------|------|------|
| 添加 | O(1) | O(n) | 最坏情况：所有key都冲突 |
| 查找 | O(1) | O(n) | 最坏情况：所有key都冲突 |
| 删除 | O(1) | O(n) | 最坏情况：所有key都冲突 |

### 自定义类型作为Key

```csharp
// 自定义类型需要正确实现GetHashCode和Equals
public class Player
{
    public int Id { get; set; }
    public string Name { get; set; }
    
    public override int GetHashCode()
    {
        // 使用Id作为哈希值（或组合多个字段）
        return Id.GetHashCode();
    }
    
    public override bool Equals(object obj)
    {
        if (obj is Player other)
            return Id == other.Id;
        return false;
    }
}

// 或者实现IEqualityComparer<T>
public class PlayerComparer : IEqualityComparer<Player>
{
    public bool Equals(Player x, Player y) => x.Id == y.Id;
    public int GetHashCode(Player obj) => obj.Id.GetHashCode();
}

var dict = new Dictionary<Player, int>(new PlayerComparer());
```

---

## 6.4 HashSet\<T\>

### 基本使用

```csharp
HashSet<int> set = new HashSet<int>();
set.Add(1);           // 添加
set.Remove(1);        // 删除
bool has = set.Contains(1);  // 检查存在

// 集合运算
set.UnionWith(other);      // 并集
set.IntersectWith(other);  // 交集
set.ExceptWith(other);     // 差集
```

### 底层实现

HashSet的实现与Dictionary类似，只是没有Value，只存储Key。

```csharp
// HashSet简化结构
public class HashSet<T>
{
    private struct Slot
    {
        public int hashCode;
        public int next;
        public T value;
    }
    
    private int[] buckets;
    private Slot[] slots;
    private int count;
}
```

### HashSet vs List

| 特性 | HashSet | List |
|------|---------|------|
| 重复元素 | 不允许 | 允许 |
| Contains | O(1) | O(n) |
| Add | O(1) | O(1)均摊 |
| 顺序 | 无序 | 有序 |
| 索引访问 | 不支持 | 支持 |
| 内存占用 | 较大 | 较小 |

### 使用场景

```csharp
// 场景1：快速判断元素是否存在
HashSet<int> visitedNodes = new HashSet<int>();
if (!visitedNodes.Contains(nodeId))
{
    visitedNodes.Add(nodeId);
    ProcessNode(nodeId);
}

// 场景2：去重
List<int> listWithDuplicates = new List<int> { 1, 2, 2, 3, 3, 3 };
HashSet<int> uniqueSet = new HashSet<int>(listWithDuplicates);
// uniqueSet: { 1, 2, 3 }

// 场景3：集合运算
HashSet<int> setA = new HashSet<int> { 1, 2, 3 };
HashSet<int> setB = new HashSet<int> { 2, 3, 4 };
setA.IntersectWith(setB);  // setA: { 2, 3 }
```

---

## 6.5 Queue\<T\> 和 Stack\<T\>

### Queue（队列）- FIFO

```csharp
Queue<int> queue = new Queue<int>();
queue.Enqueue(1);    // 入队
queue.Enqueue(2);
queue.Enqueue(3);
int first = queue.Dequeue();  // 出队，返回1
int peek = queue.Peek();      // 查看队首，不移除
```

```
队列操作：
        入队(Enqueue)
            ↓
┌───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │   │   │
└───┴───┴───┴───┴───┘
  ↑
出队(Dequeue)

先进先出(FIFO)
```

### Stack（栈）- LIFO

```csharp
Stack<int> stack = new Stack<int>();
stack.Push(1);       // 入栈
stack.Push(2);
stack.Push(3);
int top = stack.Pop();   // 出栈，返回3
int peek = stack.Peek(); // 查看栈顶，不移除
```

```
栈操作：
入栈(Push) → ┌───┐ ← 出栈(Pop)
             │ 3 │ ← 栈顶
             ├───┤
             │ 2 │
             ├───┤
             │ 1 │ ← 栈底
             └───┘

后进先出(LIFO)
```

### 时间复杂度

| 操作 | Queue | Stack |
|------|-------|-------|
| 入队/入栈 | O(1) | O(1) |
| 出队/出栈 | O(1) | O(1) |
| Peek | O(1) | O(1) |
| Contains | O(n) | O(n) |

---

## 6.6 LinkedList\<T\>

### 基本使用

```csharp
LinkedList<int> list = new LinkedList<int>();
list.AddFirst(1);    // 头部添加
list.AddLast(3);     // 尾部添加

LinkedListNode<int> node = list.Find(1);
list.AddAfter(node, 2);  // 在节点后添加

list.Remove(2);      // 删除元素
list.RemoveFirst();  // 删除头部
list.RemoveLast();   // 删除尾部
```

### 内存布局

```
LinkedList（双向链表）：

┌──────────────────────────────────────────────────────┐
│                                                      │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐          │
│  │  Node1  │◄──►│  Node2  │◄──►│  Node3  │          │
│  │ Value=1 │    │ Value=2 │    │ Value=3 │          │
│  │ Prev=null    │ Prev    │    │ Prev    │          │
│  │ Next ───┼───►│ Next ───┼───►│ Next=null          │
│  └─────────┘    └─────────┘    └─────────┘          │
│       ↑                              ↑              │
│     First                          Last             │
│                                                      │
└──────────────────────────────────────────────────────┘
```

### LinkedList vs List

| 特性 | LinkedList | List |
|------|------------|------|
| 内存布局 | 分散 | 连续 |
| 索引访问 | O(n) | O(1) |
| 头部插入 | O(1) | O(n) |
| 中间插入 | O(1)* | O(n) |
| 尾部插入 | O(1) | O(1)均摊 |
| 内存开销 | 大（每个节点有指针） | 小 |
| 缓存友好 | 差 | 好 |

*注：LinkedList中间插入需要先找到位置O(n)，插入本身O(1)

---

## 6.7 数据结构选择指南

### 选择流程图

```
需要什么操作？
│
├─► 快速查找（按key）
│   └─► Dictionary<TKey, TValue>
│
├─► 快速判断存在 + 去重
│   └─► HashSet<T>
│
├─► 有序集合 + 索引访问
│   └─► List<T> 或 数组
│
├─► 先进先出
│   └─► Queue<T>
│
├─► 后进先出
│   └─► Stack<T>
│
├─► 频繁头部/中间插入删除
│   └─► LinkedList<T>
│
└─► 键值对 + 有序
    └─► SortedDictionary<TKey, TValue>
```

### 常见场景推荐

| 场景 | 推荐数据结构 |
|------|-------------|
| 存储游戏对象列表 | List\<T\> |
| ID到对象的映射 | Dictionary\<int, T\> |
| 已访问节点记录 | HashSet\<T\> |
| 消息队列 | Queue\<T\> |
| 撤销/重做 | Stack\<T\> |
| 技能冷却管理 | Dictionary\<int, float\> |
| 排行榜 | SortedList或List+排序 |

---

## 6.8 二叉树与遍历

### 二叉树基本概念

```csharp
// 二叉树节点定义
public class TreeNode<T>
{
    public T Value;
    public TreeNode<T> Left;   // 左子节点
    public TreeNode<T> Right;  // 右子节点
    
    public TreeNode(T value)
    {
        Value = value;
        Left = null;
        Right = null;
    }
}
```

### 二叉树结构示意

```
        1           ← 根节点(Root)
       / \
      2   3         ← 第二层
     / \   \
    4   5   6       ← 叶子节点(Leaf)

术语：
- 根节点：最顶层的节点
- 叶子节点：没有子节点的节点
- 深度：从根到该节点的边数
- 高度：从该节点到最深叶子的边数
```

### 三种遍历方式

| 遍历方式 | 顺序 | 记忆口诀 |
|----------|------|----------|
| **前序遍历** | 根 → 左 → 右 | 根在**前** |
| **中序遍历** | 左 → 根 → 右 | 根在**中** |
| **后序遍历** | 左 → 右 → 根 | 根在**后** |

### 遍历示例

```
        1
       / \
      2   3
     / \
    4   5

前序遍历: 1 → 2 → 4 → 5 → 3  (根左右)
中序遍历: 4 → 2 → 5 → 1 → 3  (左根右)
后序遍历: 4 → 5 → 2 → 3 → 1  (左右根)
```

### 递归实现

```csharp
public class BinaryTree<T>
{
    // 前序遍历：根 → 左 → 右
    public void PreOrder(TreeNode<T> node, List<T> result)
    {
        if (node == null) return;
        
        result.Add(node.Value);      // 1. 访问根节点
        PreOrder(node.Left, result);  // 2. 遍历左子树
        PreOrder(node.Right, result); // 3. 遍历右子树
    }
    
    // 中序遍历：左 → 根 → 右
    public void InOrder(TreeNode<T> node, List<T> result)
    {
        if (node == null) return;
        
        InOrder(node.Left, result);   // 1. 遍历左子树
        result.Add(node.Value);       // 2. 访问根节点
        InOrder(node.Right, result);  // 3. 遍历右子树
    }
    
    // 后序遍历：左 → 右 → 根
    public void PostOrder(TreeNode<T> node, List<T> result)
    {
        if (node == null) return;
        
        PostOrder(node.Left, result);  // 1. 遍历左子树
        PostOrder(node.Right, result); // 2. 遍历右子树
        result.Add(node.Value);        // 3. 访问根节点
    }
}
```

### 非递归实现（使用栈）

```csharp
public class BinaryTreeIterative<T>
{
    // 前序遍历 - 非递归
    public List<T> PreOrderIterative(TreeNode<T> root)
    {
        List<T> result = new List<T>();
        if (root == null) return result;
        
        Stack<TreeNode<T>> stack = new Stack<TreeNode<T>>();
        stack.Push(root);
        
        while (stack.Count > 0)
        {
            TreeNode<T> node = stack.Pop();
            result.Add(node.Value);
            
            // 先压右，再压左（因为栈是LIFO）
            if (node.Right != null) stack.Push(node.Right);
            if (node.Left != null) stack.Push(node.Left);
        }
        
        return result;
    }
    
    // 中序遍历 - 非递归
    public List<T> InOrderIterative(TreeNode<T> root)
    {
        List<T> result = new List<T>();
        Stack<TreeNode<T>> stack = new Stack<TreeNode<T>>();
        TreeNode<T> current = root;
        
        while (current != null || stack.Count > 0)
        {
            // 一直往左走，把路径上的节点都压栈
            while (current != null)
            {
                stack.Push(current);
                current = current.Left;
            }
            
            // 弹出节点，访问它
            current = stack.Pop();
            result.Add(current.Value);
            
            // 转向右子树
            current = current.Right;
        }
        
        return result;
    }
    
    // 后序遍历 - 非递归（使用两个栈）
    public List<T> PostOrderIterative(TreeNode<T> root)
    {
        List<T> result = new List<T>();
        if (root == null) return result;
        
        Stack<TreeNode<T>> stack1 = new Stack<TreeNode<T>>();
        Stack<TreeNode<T>> stack2 = new Stack<TreeNode<T>>();
        
        stack1.Push(root);
        
        while (stack1.Count > 0)
        {
            TreeNode<T> node = stack1.Pop();
            stack2.Push(node);
            
            if (node.Left != null) stack1.Push(node.Left);
            if (node.Right != null) stack1.Push(node.Right);
        }
        
        while (stack2.Count > 0)
        {
            result.Add(stack2.Pop().Value);
        }
        
        return result;
    }
}
```

### 层序遍历（BFS）

```csharp
// 层序遍历 - 使用队列
public List<List<T>> LevelOrder(TreeNode<T> root)
{
    List<List<T>> result = new List<List<T>>();
    if (root == null) return result;
    
    Queue<TreeNode<T>> queue = new Queue<TreeNode<T>>();
    queue.Enqueue(root);
    
    while (queue.Count > 0)
    {
        int levelSize = queue.Count;
        List<T> currentLevel = new List<T>();
        
        for (int i = 0; i < levelSize; i++)
        {
            TreeNode<T> node = queue.Dequeue();
            currentLevel.Add(node.Value);
            
            if (node.Left != null) queue.Enqueue(node.Left);
            if (node.Right != null) queue.Enqueue(node.Right);
        }
        
        result.Add(currentLevel);
    }
    
    return result;
}
```

### 三种遍历的用途

| 遍历方式 | 典型用途 | 实际应用场景 |
|----------|----------|--------------|
| **前序遍历** | 复制树、序列化 | 保存/加载场景树、UI层级导出 |
| **中序遍历** | BST有序输出 | 排行榜、有序数据检索 |
| **后序遍历** | 删除树、计算大小 | 资源释放、文件夹大小计算 |
| **层序遍历** | 按层处理 | 寻路算法、社交网络好友推荐 |

### 为什么这三种遍历如此重要？

#### 1. 是递归思想的基础

```csharp
// 递归的核心模式：分解问题
void Solve(Problem problem)
{
    if (IsBaseCase(problem)) return;  // 基准情况
    
    Solve(LeftSubProblem);   // 分解
    Solve(RightSubProblem);  // 分解
    Combine();               // 合并
}

// 这就是后序遍历的模式！
```

#### 2. 很多复杂算法都基于树遍历

| 算法/数据结构 | 基于的遍历 | 说明 |
|---------------|-----------|------|
| **二叉搜索树(BST)** | 中序遍历 | 中序遍历得到有序序列 |
| **表达式求值** | 后序遍历 | 先算子节点，再算父节点 |
| **语法树解析** | 前序/后序 | 编译器核心 |
| **文件系统遍历** | 前序/后序 | 目录树操作 |
| **DOM树操作** | 各种遍历 | 前端核心 |
| **Unity场景树** | 前序遍历 | Transform层级 |
| **AI行为树** | 前序遍历 | 游戏AI决策 |
| **堆排序** | 层序遍历 | 优先队列 |
| **Trie树** | 前序遍历 | 字符串匹配、自动补全 |
| **线段树** | 后序遍历 | 区间查询 |
| **并查集** | 路径压缩 | 连通性判断 |

#### 3. 分治算法的基础

```csharp
// 归并排序 - 后序遍历思想
void MergeSort(int[] arr, int left, int right)
{
    if (left >= right) return;
    
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);      // 左子问题
    MergeSort(arr, mid + 1, right); // 右子问题
    Merge(arr, left, mid, right);   // 合并（后序位置）
}

// 快速排序 - 前序遍历思想
void QuickSort(int[] arr, int left, int right)
{
    if (left >= right) return;
    
    int pivot = Partition(arr, left, right);  // 处理（前序位置）
    QuickSort(arr, left, pivot - 1);          // 左子问题
    QuickSort(arr, pivot + 1, right);         // 右子问题
}
```

#### 4. 动态规划的树形结构

```csharp
// 很多DP问题可以看作树的后序遍历
// 例如：计算斐波那契数
//
//           fib(5)
//          /      \
//       fib(4)   fib(3)
//       /    \
//    fib(3) fib(2)
//    ...
//
// 后序遍历：先算子问题，再算父问题
```

### Unity中的树结构应用

```csharp
// 1. Transform层级遍历
void TraverseTransform(Transform parent)
{
    // 前序：先处理父节点
    Debug.Log(parent.name);
    
    foreach (Transform child in parent)
    {
        TraverseTransform(child);
    }
}

// 2. UI层级查找
T FindComponentInChildren<T>(Transform parent) where T : Component
{
    // 前序遍历查找
    T component = parent.GetComponent<T>();
    if (component != null) return component;
    
    foreach (Transform child in parent)
    {
        T found = FindComponentInChildren<T>(child);
        if (found != null) return found;
    }
    
    return null;
}

// 3. 销毁所有子对象（后序遍历）
void DestroyAllChildren(Transform parent)
{
    // 后序：先销毁子节点，再处理父节点
    foreach (Transform child in parent)
    {
        DestroyAllChildren(child);
    }
    
    if (parent.parent != null)  // 不销毁根节点
        Destroy(parent.gameObject);
}

// 4. 计算层级深度
int GetDepth(Transform transform)
{
    int depth = 0;
    Transform current = transform;
    while (current.parent != null)
    {
        depth++;
        current = current.parent;
    }
    return depth;
}
```

### 经典算法应用示例

#### 示例1：计算二叉树的最大深度（后序遍历）

```
问题：求二叉树的最大深度

        3
       / \
      9  20
        /  \
       15   7

答案：3（从根节点3到叶子节点15或7的路径长度）
```

**为什么用后序遍历？**
- 要知道一棵树的深度，必须先知道左右子树的深度
- 这是典型的"先处理子问题，再处理父问题"的模式
- 后序遍历：左 → 右 → 根，正好符合这个需求

```csharp
// 计算二叉树最大深度
public int MaxDepth(TreeNode<int> root)
{
    // 基准情况：空节点深度为0
    if (root == null) return 0;
    
    // 后序遍历：先递归计算左右子树深度
    int leftDepth = MaxDepth(root.Left);    // 左
    int rightDepth = MaxDepth(root.Right);  // 右
    
    // 当前节点的深度 = max(左, 右) + 1
    return Math.Max(leftDepth, rightDepth) + 1;  // 根
}

// 执行过程：
//     3          MaxDepth(3) = max(1, 2) + 1 = 3
//    / \
//   9  20        MaxDepth(9) = max(0,0)+1 = 1
//     /  \       MaxDepth(20) = max(1,1)+1 = 2
//    15   7      MaxDepth(15) = 1, MaxDepth(7) = 1
```

---

#### 示例2：判断二叉树是否对称（前序遍历变体）

```
问题：判断二叉树是否镜像对称

    对称的树：          不对称的树：
        1                   1
       / \                 / \
      2   2               2   2
     / \ / \               \   \
    3  4 4  3               3   3
```

**为什么用前序遍历？**
- 需要同时比较两个节点（左子树和右子树的镜像位置）
- 先比较当前节点，再递归比较子节点
- 这是"先处理父问题，再处理子问题"的模式

```csharp
public bool IsSymmetric(TreeNode<int> root)
{
    if (root == null) return true;
    return IsMirror(root.Left, root.Right);
}

private bool IsMirror(TreeNode<int> left, TreeNode<int> right)
{
    // 基准情况
    if (left == null && right == null) return true;
    if (left == null || right == null) return false;
    
    // 前序：先比较当前节点的值
    if (left.Value != right.Value) return false;
    
    // 再递归比较：左的左 vs 右的右，左的右 vs 右的左
    return IsMirror(left.Left, right.Right)
        && IsMirror(left.Right, right.Left);
}

// 执行过程：
//     1
//    / \
//   2   2      IsMirror(2, 2): 值相等 ✓
//  / \ / \
// 3  4 4  3    IsMirror(3, 3) ✓, IsMirror(4, 4) ✓
```

---

#### 示例3：路径总和（前序遍历 + 回溯）

```
问题：判���是否存在从根到叶子的路径，使得路径上所有节点值之和等于目标值

        5
       / \
      4   8
     /   / \
    11  13  4
   /  \      \
  7    2      1

目标值 = 22
答案：存在路径 5 → 4 → 11 → 2 = 22
```

**为什么用前序遍历？**
- 需要从根开始累加路径和
- 到达每个节点时，需要知道"到目前为止的路径和"
- 这是"先处理当前，再向下传递"的模式

```csharp
public bool HasPathSum(TreeNode<int> root, int targetSum)
{
    if (root == null) return false;
    
    // 前序：先处理当前节点
    // 如果是叶子节点，检查路径和是否等于目标
    if (root.Left == null && root.Right == null)
    {
        return root.Value == targetSum;
    }
    
    // 递归检查左右子树，目标值减去当前节点值
    int remaining = targetSum - root.Value;
    return HasPathSum(root.Left, remaining)
        || HasPathSum(root.Right, remaining);
}

// 执行过程：
// HasPathSum(5, 22) → remaining = 17
//   HasPathSum(4, 17) → remaining = 13
//     HasPathSum(11, 13) → remaining = 2
//       HasPathSum(7, 2) → 7 ≠ 2, false
//       HasPathSum(2, 2) → 2 = 2, true! ✓
```

---

#### 示例4：二叉树的序列化与反序列化（前序遍历）

```
问题：将二叉树转换为字符串，并能从字符串还原二叉树

    1
   / \
  2   3
     / \
    4   5

序列化结果："1,2,null,null,3,4,null,null,5,null,null"
```

**为什么用前序遍历？**
- 前序遍历先访问根节点，这样反序列化时可以先创建根节点
- 序列化和反序列化的顺序一致，便于还原

```csharp
public class TreeSerializer
{
    // 序列化：前序遍历
    public string Serialize(TreeNode<int> root)
    {
        StringBuilder sb = new StringBuilder();
        SerializeHelper(root, sb);
        return sb.ToString().TrimEnd(',');
    }
    
    private void SerializeHelper(TreeNode<int> node, StringBuilder sb)
    {
        if (node == null)
        {
            sb.Append("null,");
            return;
        }
        
        // 前序：根 → 左 → 右
        sb.Append(node.Value + ",");
        SerializeHelper(node.Left, sb);
        SerializeHelper(node.Right, sb);
    }
    
    // 反序列化：按前序顺序重建
    public TreeNode<int> Deserialize(string data)
    {
        Queue<string> nodes = new Queue<string>(data.Split(','));
        return DeserializeHelper(nodes);
    }
    
    private TreeNode<int> DeserializeHelper(Queue<string> nodes)
    {
        string val = nodes.Dequeue();
        if (val == "null") return null;
        
        // 前序：先创建根节点
        TreeNode<int> node = new TreeNode<int>(int.Parse(val));
        node.Left = DeserializeHelper(nodes);   // 再创建左子树
        node.Right = DeserializeHelper(nodes);  // 最后创建右子树
        
        return node;
    }
}
```

---

#### 示例5：二叉搜索树的验证（中序遍历）

```
问题：判断一棵树是否是有效的二叉搜索树（BST）

BST定义：
- 左子树所有节点 < 根节点
- 右子树所有节点 > 根节点
- 左右子树也必须是BST

    有效BST：        无效BST：
        5               5
       / \             / \
      3   7           3   7
     / \             / \
    1   4           1   6  ← 6 > 5，违反规则
```

**为什么用中序遍历？**
- BST的中序遍历结果是**严格递增**的
- 只需要检查中序遍历的结果是否递增即可

```csharp
public class BSTValidator
{
    private int? prevValue = null;
    
    public bool IsValidBST(TreeNode<int> root)
    {
        if (root == null) return true;
        
        // 中序遍历：左 → 根 → 右
        
        // 1. 先检查左子树
        if (!IsValidBST(root.Left)) return false;
        
        // 2. 检查当前节点（必须大于前一个值）
        if (prevValue.HasValue && root.Value <= prevValue.Value)
        {
            return false;
        }
        prevValue = root.Value;
        
        // 3. 检查右子树
        return IsValidBST(root.Right);
    }
}

// 执行过程（有效BST）：
//     5
//    / \
//   3   7
//  / \
// 1   4
//
// 中序遍历顺序：1 → 3 → 4 → 5 → 7
// 检查：1 < 3 < 4 < 5 < 7 ✓ 严格递增，是有效BST
```

---

#### 示例6：最近公共祖先（后序遍历）

```
问题：找到二叉树中两个节点的最近公共祖先（LCA）

        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

节点5和节点1的LCA是3
节点5和节点4的LCA是5
```

**为什么用后序遍历？**
- 需要先知道左右子树中是否包含目标节点
- 然后才能判断当前节点是否是LCA
- 这是典型的"先处理子问题，再处理父问题"

```csharp
public TreeNode<int> LowestCommonAncestor(TreeNode<int> root,
    TreeNode<int> p, TreeNode<int> q)
{
    // 基准情况
    if (root == null) return null;
    if (root == p || root == q) return root;
    
    // 后序遍历：先在左右子树中查找
    TreeNode<int> left = LowestCommonAncestor(root.Left, p, q);
    TreeNode<int> right = LowestCommonAncestor(root.Right, p, q);
    
    // 根据左右子树的结果判断
    if (left != null && right != null)
    {
        // p和q分别在左右子树中，当前节点就是LCA
        return root;
    }
    
    // 否则返回非空的那个
    return left ?? right;
}

// 执行过程（找5和1的LCA）：
//        3          ← left=5, right=1, 都非空，返回3
//       / \
//      5   1        ← 找到5，返回5    ← 找到1，返回1
//     / \
//    6   2          ← 返回null
```

---

#### 示例7：从前序和中序遍历构建二叉树

```
问题：给定前序和中序遍历结果，重建二叉树

前序遍历: [3, 9, 20, 15, 7]  （根左右）
中序遍历: [9, 3, 15, 20, 7]  （左根右）

重建结果：
    3
   / \
  9  20
    /  \
   15   7
```

**为什么能重建？**
- 前序遍历的第一个元素一定是根节点
- 在中序遍历中找到根节点���左边是左子树，右边是右子树
- 递归处理左右子树

```csharp
public class TreeBuilder
{
    private Dictionary<int, int> inorderIndexMap;
    private int preorderIndex = 0;
    
    public TreeNode<int> BuildTree(int[] preorder, int[] inorder)
    {
        // 建立中序遍历的值到索引的映射，方便快速查找
        inorderIndexMap = new Dictionary<int, int>();
        for (int i = 0; i < inorder.Length; i++)
        {
            inorderIndexMap[inorder[i]] = i;
        }
        
        return Build(preorder, 0, inorder.Length - 1);
    }
    
    private TreeNode<int> Build(int[] preorder, int inLeft, int inRight)
    {
        if (inLeft > inRight) return null;
        
        // 前序遍历的当前元素是根节点
        int rootVal = preorder[preorderIndex++];
        TreeNode<int> root = new TreeNode<int>(rootVal);
        
        // 在中序遍历中找到根节点的位置
        int inorderRootIndex = inorderIndexMap[rootVal];
        
        // 递归构建左右子树
        // 注意：必须先构建左子树，因为前序遍历是"根左右"
        root.Left = Build(preorder, inLeft, inorderRootIndex - 1);
        root.Right = Build(preorder, inorderRootIndex + 1, inRight);
        
        return root;
    }
}

// 执行过程：
// 前序: [3, 9, 20, 15, 7]
// 中序: [9, 3, 15, 20, 7]
//
// 1. 前序第一个是3，是根节点
// 2. 中序中3的位置是1，左边[9]是左子树，右边[15,20,7]是右子树
// 3. 递归处理左子树：前序[9]，中序[9] → 节点9
// 4. 递归处理右子树：前序[20,15,7]，中序[15,20,7]
//    - 20是根，左边[15]，右边[7]
```

---

### 遍历方式选择总结

| 场景 | 选择的遍历 | 原因 |
|------|-----------|------|
| 计算深度/高度 | 后序 | 需要先知道子树信息 |
| 计算节点数 | 后序 | 需要先知道子树节点数 |
| 判断对称/相等 | 前序 | 先比较当前，再比较子树 |
| 路径问题 | 前序 | 从根向下累积信息 |
| 序列化/复制 | 前序 | 先处理根，便于重建 |
| BST有序输出 | 中序 | 中序遍历BST得到有序序列 |
| BST验证 | 中序 | 检查是否严格递增 |
| 删除树/释放资源 | 后序 | 先删除子节点，再删除父节点 |
| 表达式求值 | 后序 | 先算子表达式，再算父表达式 |
| 最近公共祖先 | 后序 | 需要先知道子树中是否包含目标 |

---

### 二叉搜索树（BST）

```csharp
public class BinarySearchTree
{
    private TreeNode<int> root;
    
    // 插入
    public void Insert(int value)
    {
        root = InsertRecursive(root, value);
    }
    
    private TreeNode<int> InsertRecursive(TreeNode<int> node, int value)
    {
        if (node == null) return new TreeNode<int>(value);
        
        if (value < node.Value)
            node.Left = InsertRecursive(node.Left, value);
        else if (value > node.Value)
            node.Right = InsertRecursive(node.Right, value);
        
        return node;
    }
    
    // 查找
    public bool Search(int value)
    {
        return SearchRecursive(root, value);
    }
    
    private bool SearchRecursive(TreeNode<int> node, int value)
    {
        if (node == null) return false;
        if (value == node.Value) return true;
        
        if (value < node.Value)
            return SearchRecursive(node.Left, value);
        else
            return SearchRecursive(node.Right, value);
    }
    
    // 中序遍历得到有序序列
    public List<int> GetSortedList()
    {
        List<int> result = new List<int>();
        InOrder(root, result);
        return result;
    }
    
    private void InOrder(TreeNode<int> node, List<int> result)
    {
        if (node == null) return;
        InOrder(node.Left, result);
        result.Add(node.Value);
        InOrder(node.Right, result);
    }
}
```

### 时间复杂度

| 操作 | 平衡树 | 最坏情况（退化为链表） |
|------|--------|----------------------|
| 查找 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |
| 遍历 | O(n) | O(n) |

---

## 6.9 Unity中的特殊考虑

### 避免GC的数据结构使用

```csharp
public class ObjectPool : MonoBehaviour
{
    // 使用List而不是频繁new/destroy
    private List<GameObject> pool = new List<GameObject>();
    
    // 预分配容量
    void Start()
    {
        pool = new List<GameObject>(100);
        for (int i = 0; i < 100; i++)
        {
            var obj = Instantiate(prefab);
            obj.SetActive(false);
            pool.Add(obj);
        }
    }
}
```

### NativeContainer（DOTS）

```csharp
using Unity.Collections;

// 原生数组，不产生GC
NativeArray<int> nativeArray = new NativeArray<int>(100, Allocator.TempJob);

// 原生列表
NativeList<int> nativeList = new NativeList<int>(Allocator.TempJob);

// 原生哈希表
NativeHashMap<int, float> nativeMap = new NativeHashMap<int, float>(100, Allocator.TempJob);

// 使用完必须手动释放
nativeArray.Dispose();
nativeList.Dispose();
nativeMap.Dispose();
```

---

## 面试要点总结

### 问题23：List和数组的区别是什么？

**答案要点：**
1. **大小**：数组固定，List动态
2. **扩容**：List容量不足时翻倍扩容，会产生GC
3. **功能**：List提供Add、Remove等方法
4. **性能**：底层都是数组，访问都是O(1)
5. **优化**：预分配List容量避免扩容

### 问题24：Dictionary的底层实现原理是什么？

**答案要点：**
1. **哈希表**：通过哈希函数将key映射到桶索引
2. **结构**：buckets数组 + entries数组
3. **冲突处理**：链地址法，同一桶的元素形成链表
4. **时间复杂度**：平均O(1)，最坏O(n)
5. **自定义key**：需要正确实现GetHashCode和Equals

### 问题25：HashSet和List的区别是什么？

**答案要点：**
1. **重复**：HashSet不允许重复，List允许
2. **Contains**：HashSet O(1)，List O(n)
3. **顺序**：HashSet无序，List有序
4. **索引**：HashSet不支持索引访问
5. **场景**：HashSet用于去重和快速查找

### 问题26：如何选择合适的数据结构？

**答案要点：**
- 按key查找 → Dictionary
- 去重/判断存在 → HashSet
- 有序+索引 → List
- FIFO → Queue
- LIFO → Stack
- 频繁插入删除 → LinkedList

### 问题27：常见数据结构的时间复杂度是多少？

| 数据结构 | 访问 | 查找 | 插入 | 删除 |
|----------|------|------|------|------|
| Array | O(1) | O(n) | - | - |
| List | O(1) | O(n) | O(n)* | O(n) |
| Dictionary | - | O(1) | O(1) | O(1) |
| HashSet | - | O(1) | O(1) | O(1) |
| LinkedList | O(n) | O(n) | O(1)** | O(1)** |

*List末尾插入均摊O(1)
**LinkedList需要先找到位置

### 问题28：二叉树的前中后序遍历是什么？有什么用途？

**答案要点：**

1. **三种遍历方式**：
   - 前序遍历：根 → 左 → 右（用于复制树、序列化）
   - 中序遍历：左 → 根 → 右（BST中得到有序序列）
   - 后序遍历：左 → 右 → 根（用于删除树、计算大小）

2. **为什么重要**：
   - 是递归思想的基础模式
   - 分治算法的核心（归并排序=后序，快排=前序）
   - 动态规划的树形结构理解
   - 很多复杂数据结构都基于树（BST、堆、Trie、线段树等）

3. **Unity中的应用**：
   - Transform层级遍历
   - UI组件查找
   - 场景树序列化/反序列化
   - AI行为树执行

4. **实现方式**：
   - 递归实现：代码简洁，但有栈溢出风险
   - 非递归实现：使用显式栈，更安全
   - 层序遍历：使用队列（BFS）

5. **时间复杂度**：
   - 遍历：O(n)
   - BST查找/插入：平均O(log n)，最坏O(n)

---

[返回目录](./00_目录.md) | [上一章：物理与Update](./05_物理与Update.md) | [下一章：C#基础](./07_CSharp基础.md)