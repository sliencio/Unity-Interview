# 十七、设计模式

> 本章涵盖问题：
> - Unity中常用的设计模式有哪些？
> - 如何实现单例模式？有什么注意事项？

---

## 17.1 设计模式概述

### 设计模式分类

```
设计模式分类：

创建型模式（对象创建）
├─ 单例模式（Singleton）
├─ 工厂模式（Factory）
├─ 抽象工厂模式（Abstract Factory）
├─ 建造者模式（Builder）
└─ 原型模式（Prototype）

结构型模式（对象组合）
├─ 适配器模式（Adapter）
├─ 装饰器模式（Decorator）
├─ 代理模式（Proxy）
├─ 外观模式（Facade）
├─ 桥接模式（Bridge）
├─ 组合模式（Composite）
└─ 享元模式（Flyweight）

行为型模式（对象交互）
├─ 观察者模式（Observer）
├─ 策略模式（Strategy）
├─ 命令模式（Command）
├─ 状态模式（State）
├─ 模板方法模式（Template Method）
├─ 迭代器模式（Iterator）
├─ 中介者模式（Mediator）
├─ 备忘录模式（Memento）
├─ 访问者模式（Visitor）
├─ 责任链模式（Chain of Responsibility）
└─ 解释器模式（Interpreter）
```

### Unity中常用的设计模式

| 模式 | 应用场景 |
|------|----------|
| 单例模式 | 管理器类（GameManager、AudioManager） |
| 观察者模式 | 事件系统、消息通知 |
| 状态模式 | AI状态机、角色状态 |
| 命令模式 | 输入处理、撤销/重做 |
| 工厂模式 | 对象创建、对象池 |
| 策略模式 | AI行为、技能系统 |
| 组件模式 | Unity本身的设计 |
| 对象池模式 | 子弹、特效、敌人 |

---

## 17.2 单例模式

### 基本实现

```csharp
// 最简单的单例
public class GameManager
{
    private static GameManager instance;
    
    public static GameManager Instance
    {
        get
        {
            if (instance == null)
            {
                instance = new GameManager();
            }
            return instance;
        }
    }
    
    private GameManager() { }  // 私有构造函数
}
```

### 线程安全单例

```csharp
// 线程安全的单例（双重检查锁定）
public class ThreadSafeSingleton
{
    private static ThreadSafeSingleton instance;
    private static readonly object lockObj = new object();
    
    public static ThreadSafeSingleton Instance
    {
        get
        {
            if (instance == null)
            {
                lock (lockObj)
                {
                    if (instance == null)
                    {
                        instance = new ThreadSafeSingleton();
                    }
                }
            }
            return instance;
        }
    }
    
    private ThreadSafeSingleton() { }
}

// 使用Lazy<T>的线程安全单例
public class LazySingleton
{
    private static readonly Lazy<LazySingleton> lazy = 
        new Lazy<LazySingleton>(() => new LazySingleton());
    
    public static LazySingleton Instance => lazy.Value;
    
    private LazySingleton() { }
}
```

### Unity MonoBehaviour单例

```csharp
// 基础MonoBehaviour单例
public class MonoSingleton<T> : MonoBehaviour where T : MonoBehaviour
{
    private static T instance;
    private static readonly object lockObj = new object();
    private static bool applicationIsQuitting = false;
    
    public static T Instance
    {
        get
        {
            if (applicationIsQuitting)
            {
                Debug.LogWarning($"[Singleton] Instance '{typeof(T)}' already destroyed.");
                return null;
            }
            
            lock (lockObj)
            {
                if (instance == null)
                {
                    // 查找场景中是否已存在
                    instance = FindObjectOfType<T>();
                    
                    if (instance == null)
                    {
                        // 创建新的GameObject
                        GameObject singletonObject = new GameObject();
                        instance = singletonObject.AddComponent<T>();
                        singletonObject.name = $"[Singleton] {typeof(T)}";
                        
                        DontDestroyOnLoad(singletonObject);
                    }
                }
                
                return instance;
            }
        }
    }
    
    protected virtual void Awake()
    {
        if (instance == null)
        {
            instance = this as T;
            DontDestroyOnLoad(gameObject);
        }
        else if (instance != this)
        {
            Destroy(gameObject);
        }
    }
    
    protected virtual void OnApplicationQuit()
    {
        applicationIsQuitting = true;
    }
    
    protected virtual void OnDestroy()
    {
        if (instance == this)
        {
            applicationIsQuitting = true;
        }
    }
}

// 使用
public class GameManager : MonoSingleton<GameManager>
{
    public int score;
    
    protected override void Awake()
    {
        base.Awake();
        // 初始化
    }
}

// 调用
GameManager.Instance.score = 100;
```

### 单例的注意事项

```csharp
// 1. 避免在OnDestroy中访问其他单例
void OnDestroy()
{
    // 不好：可能访问已销毁的单例
    AudioManager.Instance.PlaySound("death");
    
    // 好：检查是否正在退出
    if (!applicationIsQuitting)
    {
        AudioManager.Instance.PlaySound("death");
    }
}

// 2. 注意初始化顺序
// 单例之间的依赖可能导致问题
public class A : MonoSingleton<A>
{
    protected override void Awake()
    {
        base.Awake();
        B.Instance.DoSomething();  // B可能还未初始化
    }
}

// 3. 考虑使用依赖注入代替单例
// 单例难以测试，依赖注入更灵活
```

---

## 17.3 观察者模式

### 基本实现

```csharp
// 使用C#事件
public class EventManager
{
    // 定义事件
    public event Action<int> OnScoreChanged;
    public event Action<Player> OnPlayerDeath;
    
    // 触发事件
    public void ChangeScore(int newScore)
    {
        OnScoreChanged?.Invoke(newScore);
    }
    
    public void PlayerDied(Player player)
    {
        OnPlayerDeath?.Invoke(player);
    }
}

// 订阅者
public class ScoreUI : MonoBehaviour
{
    void Start()
    {
        EventManager.Instance.OnScoreChanged += UpdateScoreDisplay;
    }
    
    void OnDestroy()
    {
        EventManager.Instance.OnScoreChanged -= UpdateScoreDisplay;
    }
    
    void UpdateScoreDisplay(int score)
    {
        scoreText.text = score.ToString();
    }
}
```

### 通用事件系统

```csharp
public class EventCenter
{
    private static Dictionary<string, Delegate> eventTable = 
        new Dictionary<string, Delegate>();
    
    // 添加监听
    public static void AddListener<T>(string eventType, Action<T> handler)
    {
        if (!eventTable.ContainsKey(eventType))
        {
            eventTable[eventType] = null;
        }
        eventTable[eventType] = (Action<T>)eventTable[eventType] + handler;
    }
    
    // 移除监听
    public static void RemoveListener<T>(string eventType, Action<T> handler)
    {
        if (eventTable.ContainsKey(eventType))
        {
            eventTable[eventType] = (Action<T>)eventTable[eventType] - handler;
        }
    }
    
    // 触发事件
    public static void Broadcast<T>(string eventType, T arg)
    {
        if (eventTable.TryGetValue(eventType, out Delegate d))
        {
            (d as Action<T>)?.Invoke(arg);
        }
    }
    
    // 清理
    public static void Clear()
    {
        eventTable.Clear();
    }
}

// 使用
EventCenter.AddListener<int>("ScoreChanged", OnScoreChanged);
EventCenter.Broadcast("ScoreChanged", 100);
EventCenter.RemoveListener<int>("ScoreChanged", OnScoreChanged);
```

---

## 17.4 状态模式

### 基本实现

```csharp
// 状态接口
public interface IState
{
    void Enter();
    void Update();
    void Exit();
}

// 具体状态
public class IdleState : IState
{
    private Player player;
    
    public IdleState(Player player)
    {
        this.player = player;
    }
    
    public void Enter()
    {
        player.animator.Play("Idle");
    }
    
    public void Update()
    {
        if (Input.GetAxis("Horizontal") != 0)
        {
            player.ChangeState(new WalkState(player));
        }
    }
    
    public void Exit() { }
}

public class WalkState : IState
{
    private Player player;
    
    public WalkState(Player player)
    {
        this.player = player;
    }
    
    public void Enter()
    {
        player.animator.Play("Walk");
    }
    
    public void Update()
    {
        float h = Input.GetAxis("Horizontal");
        if (h == 0)
        {
            player.ChangeState(new IdleState(player));
        }
        else
        {
            player.Move(h);
        }
    }
    
    public void Exit() { }
}

// 状态机持有者
public class Player : MonoBehaviour
{
    public Animator animator;
    private IState currentState;
    
    void Start()
    {
        ChangeState(new IdleState(this));
    }
    
    void Update()
    {
        currentState?.Update();
    }
    
    public void ChangeState(IState newState)
    {
        currentState?.Exit();
        currentState = newState;
        currentState?.Enter();
    }
    
    public void Move(float direction)
    {
        transform.Translate(Vector3.right * direction * Time.deltaTime);
    }
}
```

### 使用枚举的简化版本

```csharp
public class SimpleStateMachine : MonoBehaviour
{
    public enum State { Idle, Walk, Run, Jump }
    
    private State currentState = State.Idle;
    
    void Update()
    {
        switch (currentState)
        {
            case State.Idle:
                UpdateIdle();
                break;
            case State.Walk:
                UpdateWalk();
                break;
            case State.Run:
                UpdateRun();
                break;
            case State.Jump:
                UpdateJump();
                break;
        }
    }
    
    void ChangeState(State newState)
    {
        ExitState(currentState);
        currentState = newState;
        EnterState(currentState);
    }
    
    void EnterState(State state) { }
    void ExitState(State state) { }
    void UpdateIdle() { }
    void UpdateWalk() { }
    void UpdateRun() { }
    void UpdateJump() { }
}
```

---

## 17.5 命令模式

### 基本实现

```csharp
// 命令接口
public interface ICommand
{
    void Execute();
    void Undo();
}

// 具体命令
public class MoveCommand : ICommand
{
    private Transform transform;
    private Vector3 direction;
    private Vector3 previousPosition;
    
    public MoveCommand(Transform transform, Vector3 direction)
    {
        this.transform = transform;
        this.direction = direction;
    }
    
    public void Execute()
    {
        previousPosition = transform.position;
        transform.position += direction;
    }
    
    public void Undo()
    {
        transform.position = previousPosition;
    }
}

// 命令管理器
public class CommandManager
{
    private Stack<ICommand> undoStack = new Stack<ICommand>();
    private Stack<ICommand> redoStack = new Stack<ICommand>();
    
    public void ExecuteCommand(ICommand command)
    {
        command.Execute();
        undoStack.Push(command);
        redoStack.Clear();
    }
    
    public void Undo()
    {
        if (undoStack.Count > 0)
        {
            ICommand command = undoStack.Pop();
            command.Undo();
            redoStack.Push(command);
        }
    }
    
    public void Redo()
    {
        if (redoStack.Count > 0)
        {
            ICommand command = redoStack.Pop();
            command.Execute();
            undoStack.Push(command);
        }
    }
}

// 使用
CommandManager commandManager = new CommandManager();
commandManager.ExecuteCommand(new MoveCommand(player.transform, Vector3.forward));
commandManager.Undo();
commandManager.Redo();
```

---

## 17.6 工厂模式

### 简单工厂

```csharp
// 产品接口
public interface IEnemy
{
    void Attack();
}

// 具体产品
public class Zombie : IEnemy
{
    public void Attack() => Debug.Log("Zombie attacks!");
}

public class Skeleton : IEnemy
{
    public void Attack() => Debug.Log("Skeleton attacks!");
}

// 简单工厂
public class EnemyFactory
{
    public static IEnemy CreateEnemy(string type)
    {
        switch (type)
        {
            case "Zombie": return new Zombie();
            case "Skeleton": return new Skeleton();
            default: throw new ArgumentException("Unknown enemy type");
        }
    }
}

// 使用
IEnemy enemy = EnemyFactory.CreateEnemy("Zombie");
enemy.Attack();
```

### 工厂方法

```csharp
// 工厂接口
public interface IEnemyFactory
{
    IEnemy CreateEnemy();
}

// 具体工厂
public class ZombieFactory : IEnemyFactory
{
    public IEnemy CreateEnemy() => new Zombie();
}

public class SkeletonFactory : IEnemyFactory
{
    public IEnemy CreateEnemy() => new Skeleton();
}

// 使用
IEnemyFactory factory = new ZombieFactory();
IEnemy enemy = factory.CreateEnemy();
```

---

## 17.7 对象池模式

### 通用对象池

```csharp
public class ObjectPool<T> where T : class
{
    private readonly Stack<T> pool = new Stack<T>();
    private readonly Func<T> createFunc;
    private readonly Action<T> onGet;
    private readonly Action<T> onRelease;
    private readonly int maxSize;
    
    public ObjectPool(
        Func<T> createFunc,
        Action<T> onGet = null,
        Action<T> onRelease = null,
        int initialSize = 10,
        int maxSize = 100)
    {
        this.createFunc = createFunc;
        this.onGet = onGet;
        this.onRelease = onRelease;
        this.maxSize = maxSize;
        
        for (int i = 0; i < initialSize; i++)
        {
            pool.Push(createFunc());
        }
    }
    
    public T Get()
    {
        T item = pool.Count > 0 ? pool.Pop() : createFunc();
        onGet?.Invoke(item);
        return item;
    }
    
    public void Release(T item)
    {
        if (pool.Count < maxSize)
        {
            onRelease?.Invoke(item);
            pool.Push(item);
        }
    }
    
    public void Clear()
    {
        pool.Clear();
    }
}

// GameObject对象池
public class GameObjectPool
{
    private readonly GameObject prefab;
    private readonly Transform parent;
    private readonly Stack<GameObject> pool = new Stack<GameObject>();
    
    public GameObjectPool(GameObject prefab, Transform parent, int initialSize = 10)
    {
        this.prefab = prefab;
        this.parent = parent;
        
        for (int i = 0; i < initialSize; i++)
        {
            var obj = Object.Instantiate(prefab, parent);
            obj.SetActive(false);
            pool.Push(obj);
        }
    }
    
    public GameObject Get()
    {
        GameObject obj;
        if (pool.Count > 0)
        {
            obj = pool.Pop();
        }
        else
        {
            obj = Object.Instantiate(prefab, parent);
        }
        obj.SetActive(true);
        return obj;
    }
    
    public void Release(GameObject obj)
    {
        obj.SetActive(false);
        pool.Push(obj);
    }
}
```

---

## 17.8 策略模式

### 基本实现

```csharp
// 策略接口
public interface IAttackStrategy
{
    void Attack(Character attacker, Character target);
}

// 具体策略
public class MeleeAttack : IAttackStrategy
{
    public void Attack(Character attacker, Character target)
    {
        if (Vector3.Distance(attacker.Position, target.Position) < 2f)
        {
            target.TakeDamage(attacker.MeleeDamage);
        }
    }
}

public class RangedAttack : IAttackStrategy
{
    public void Attack(Character attacker, Character target)
    {
        // 发射子弹
        var bullet = BulletPool.Get();
        bullet.Fire(attacker.Position, target.Position, attacker.RangedDamage);
    }
}

public class MagicAttack : IAttackStrategy
{
    public void Attack(Character attacker, Character target)
    {
        // 释放魔法
        target.TakeDamage(attacker.MagicDamage);
        target.ApplyDebuff(DebuffType.Slow);
    }
}

// 使用策略的角色
public class Character
{
    private IAttackStrategy attackStrategy;
    
    public void SetAttackStrategy(IAttackStrategy strategy)
    {
        attackStrategy = strategy;
    }
    
    public void Attack(Character target)
    {
        attackStrategy?.Attack(this, target);
    }
}

// 使用
Character warrior = new Character();
warrior.SetAttackStrategy(new MeleeAttack());
warrior.Attack(enemy);

warrior.SetAttackStrategy(new RangedAttack());  // 切换策略
warrior.Attack(enemy);
```

---

## 面试要点总结

### 问题87：Unity中常用的设计模式有哪些？

**答案要点：**

| 模式 | 应用场景 |
|------|----------|
| 单例模式 | 管理器类 |
| 观察者模式 | 事件系统 |
| 状态模式 | AI状态机 |
| 命令模式 | 输入处理、撤销重做 |
| 工厂模式 | 对象创建 |
| 对象池模式 | 频繁创建销毁的对象 |
| 策略模式 | AI行为、技能系统 |
| 组件模式 | Unity本身设计 |

### 问题88：如何实现单例模式？有什么注意事项？

**答案要点：**

1. **实现方式**：
   - 普通类：私有构造函数 + 静态Instance属性
   - MonoBehaviour：继承MonoSingleton基类
   - 线程安全：双重检查锁定或Lazy<T>

2. **注意事项**：
   - 避免在OnDestroy中访问其他单例
   - 注意初始化顺序
   - 使用DontDestroyOnLoad跨场景
   - 处理applicationIsQuitting标志
   - 考虑使用依赖注入代替

3. **MonoBehaviour单例要点**：
   - 检查是否已存在实例
   - 处理重复实例（Destroy）
   - 跨场景保持（DontDestroyOnLoad）

---

[返回目录](./00_目录.md) | [上一章：JIT内联](./16_JIT内联.md) | [下一章：其他](./18_其他.md)