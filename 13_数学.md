# 十三、数学

> 本章涵盖问题：
> - 向量的点积和叉积有什么用？
> - 四元数是什么？为什么用四元数表示旋转？

---

## 13.1 向量基础

### 向量的表示

```csharp
// Unity中的向量
Vector2 v2 = new Vector2(1, 2);
Vector3 v3 = new Vector3(1, 2, 3);
Vector4 v4 = new Vector4(1, 2, 3, 4);

// 常用向量
Vector3.zero;      // (0, 0, 0)
Vector3.one;       // (1, 1, 1)
Vector3.up;        // (0, 1, 0)
Vector3.down;      // (0, -1, 0)
Vector3.left;      // (-1, 0, 0)
Vector3.right;     // (1, 0, 0)
Vector3.forward;   // (0, 0, 1)
Vector3.back;      // (0, 0, -1)
```

### 向量运算

```csharp
Vector3 a = new Vector3(1, 2, 3);
Vector3 b = new Vector3(4, 5, 6);

// 加法
Vector3 sum = a + b;  // (5, 7, 9)

// 减法
Vector3 diff = a - b;  // (-3, -3, -3)

// 标量乘法
Vector3 scaled = a * 2;  // (2, 4, 6)

// 长度（模）
float length = a.magnitude;  // sqrt(1² + 2² + 3²) = sqrt(14)

// 单位向量（归一化）
Vector3 normalized = a.normalized;  // a / |a|

// 距离
float distance = Vector3.Distance(a, b);
```

---

## 13.2 点积（Dot Product）

### 定义和公式

```
点积（内积、数量积）：

代数定义：
a · b = a.x * b.x + a.y * b.y + a.z * b.z

几何定义：
a · b = |a| * |b| * cos(θ)

其中θ是两向量的夹角
```

### 点积的几何意义

```
点积 = 投影长度 × 被投影向量长度

        b
       /
      /
     /
    /θ
   ●───────────────► a
   
a · b = |a| * |b| * cos(θ)
      = |a| * (b在a方向的投影长度)
      = |b| * (a在b方向的投影长度)
```

### 点积的应用

```csharp
// 1. 判断两向量的夹角关系
float dot = Vector3.Dot(a, b);
// dot > 0：夹角 < 90°（同向）
// dot = 0：夹角 = 90°（垂直）
// dot < 0：夹角 > 90°（反向）

// 2. 计算夹角
float angle = Mathf.Acos(Vector3.Dot(a.normalized, b.normalized)) * Mathf.Rad2Deg;
// 或使用Unity内置方法
float angle = Vector3.Angle(a, b);

// 3. 判断目标是否在前方
Vector3 toTarget = (target.position - transform.position).normalized;
Vector3 forward = transform.forward;
float dot = Vector3.Dot(forward, toTarget);
bool isInFront = dot > 0;

// 4. 判断是否在视野内
float fovCos = Mathf.Cos(fovAngle * 0.5f * Mathf.Deg2Rad);
bool isInFOV = dot > fovCos;

// 5. 计算投影
Vector3 projection = Vector3.Dot(a, b.normalized) * b.normalized;
```

### 视野检测示例

```csharp
public class FOVDetection : MonoBehaviour
{
    public float fovAngle = 90f;
    public float viewDistance = 10f;
    
    public bool IsTargetVisible(Transform target)
    {
        Vector3 toTarget = target.position - transform.position;
        float distance = toTarget.magnitude;
        
        // 距离检测
        if (distance > viewDistance)
            return false;
        
        // 角度检测（使用点积）
        Vector3 forward = transform.forward;
        Vector3 dirToTarget = toTarget.normalized;
        
        float dot = Vector3.Dot(forward, dirToTarget);
        float fovCos = Mathf.Cos(fovAngle * 0.5f * Mathf.Deg2Rad);
        
        return dot >= fovCos;
    }
}
```

---

## 13.3 叉积（Cross Product）

### 定义和公式

```
叉积（外积、向量积）：

结果是一个向量，垂直于原来两个向量

a × b = (a.y*b.z - a.z*b.y, 
         a.z*b.x - a.x*b.z, 
         a.x*b.y - a.y*b.x)

|a × b| = |a| * |b| * sin(θ)
```

### 叉积的几何意义

```
叉积结果垂直于两个原向量（右手定则）：

        a × b
          ↑
          │
          │
          ●───────► a
         /
        /
       ↙
      b

右手定则：
• 四指从a转向b
• 大拇指指向a × b的方向

|a × b| = 平行四边形面积
```

### 叉积的应用

```csharp
// 1. 计算垂直向量（法向量）
Vector3 normal = Vector3.Cross(edge1, edge2).normalized;

// 2. 判断左右（2D中常用）
Vector3 cross = Vector3.Cross(forward, toTarget);
// cross.y > 0：目标在左边
// cross.y < 0：目标在右边

// 3. 计算旋转轴
Vector3 rotationAxis = Vector3.Cross(from, to).normalized;

// 4. 计算三角形面积
float area = Vector3.Cross(edge1, edge2).magnitude * 0.5f;

// 5. 判断点在三角形内
bool IsPointInTriangle(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
{
    Vector3 ab = b - a;
    Vector3 bc = c - b;
    Vector3 ca = a - c;
    
    Vector3 ap = p - a;
    Vector3 bp = p - b;
    Vector3 cp = p - c;
    
    Vector3 cross1 = Vector3.Cross(ab, ap);
    Vector3 cross2 = Vector3.Cross(bc, bp);
    Vector3 cross3 = Vector3.Cross(ca, cp);
    
    // 如果三个叉积方向相同，点在三角形内
    return Vector3.Dot(cross1, cross2) >= 0 && 
           Vector3.Dot(cross2, cross3) >= 0;
}
```

### 左右判断示例

```csharp
public class DirectionDetection : MonoBehaviour
{
    public Transform target;
    
    void Update()
    {
        Vector3 toTarget = target.position - transform.position;
        Vector3 cross = Vector3.Cross(transform.forward, toTarget);
        
        if (cross.y > 0.1f)
        {
            Debug.Log("目标在左边");
        }
        else if (cross.y < -0.1f)
        {
            Debug.Log("目标在右边");
        }
        else
        {
            Debug.Log("目标在正前方或正后方");
        }
    }
}
```

---

## 13.4 四元数（Quaternion）

### 为什么需要四元数

```
旋转的表示方式：

1. 欧拉角（Euler Angles）
   ├─ 优点：直观，易理解
   └─ 缺点：万向节锁（Gimbal Lock）

2. 旋转矩阵（Rotation Matrix）
   ├─ 优点：无万向节锁
   └─ 缺点：9个数，冗余，插值困难

3. 四元数（Quaternion）
   ├─ 优点：无万向节锁，4个数，插值平滑
   └─ 缺点：不直观
```

### 万向节锁问题

```
万向节锁（Gimbal Lock）：

当一个轴旋转90°时，另外两个轴重合，丢失一个自由度

示例：Y轴旋转90°后
┌─────────────────────────────────────┐
│ 初始状态：                          │
│ X轴：左右                           │
│ Y轴：上下                           │
│ Z轴：前后                           │
│                                     │
│ Y轴旋转90°后：                      │
│ X轴：前后（与原Z轴重合！）          │
│ Y轴：上下                           │
│ Z轴：左右                           │
│                                     │
│ 此时X轴和Z轴的旋转效果相同          │
│ 丢失了一个旋转自由度                │
└─────────────────────────────────────┘
```

### 四元数的定义

```
四元数：q = w + xi + yj + zk

其中：
• w 是实部（标量部分）
• (x, y, z) 是虚部（向量部分）
• i, j, k 是虚数单位

i² = j² = k² = ijk = -1

表示旋转：
q = cos(θ/2) + sin(θ/2) * (axis.x*i + axis.y*j + axis.z*k)

其中：
• θ 是旋转角度
• axis 是旋转轴（单位向量）
```

### Unity中的四元数

```csharp
// 创建四元数
Quaternion q1 = Quaternion.identity;  // 无旋转
Quaternion q2 = Quaternion.Euler(0, 90, 0);  // 从欧拉角创建
Quaternion q3 = Quaternion.AngleAxis(90, Vector3.up);  // 绕轴旋转
Quaternion q4 = Quaternion.LookRotation(forward, up);  // 朝向

// 四元数运算
Quaternion combined = q1 * q2;  // 组合旋转（注意顺序）
Vector3 rotatedPoint = q1 * point;  // 旋转向量

// 转换
Vector3 euler = q1.eulerAngles;  // 转欧拉角
q1.ToAngleAxis(out float angle, out Vector3 axis);  // 转轴角

// 插值
Quaternion lerped = Quaternion.Lerp(q1, q2, t);  // 线性插值
Quaternion slerped = Quaternion.Slerp(q1, q2, t);  // 球面插值（更平滑）

// 常用方法
Quaternion inverse = Quaternion.Inverse(q1);  // 逆四元数
float angle = Quaternion.Angle(q1, q2);  // 夹角
Quaternion rotated = Quaternion.RotateTowards(q1, q2, maxDegrees);  // 限速旋转
```

### Lerp vs Slerp

```
Lerp（线性插值）：
• 直线路径
• 速度不均匀（中间快，两端慢）
• 计算快

Slerp（球面线性插值）：
• 球面路径
• 速度均匀
• 计算稍慢
• 旋转更自然

        Slerp路径
       ╭─────────╮
      ╱           ╲
     ●             ●
      ╲           ╱
       ╰─────────╯
        Lerp路径
```

### 四元数应用示例

```csharp
// 1. 平滑旋转到目标
public class SmoothRotation : MonoBehaviour
{
    public Transform target;
    public float rotationSpeed = 5f;
    
    void Update()
    {
        Vector3 direction = target.position - transform.position;
        Quaternion targetRotation = Quaternion.LookRotation(direction);
        
        transform.rotation = Quaternion.Slerp(
            transform.rotation,
            targetRotation,
            rotationSpeed * Time.deltaTime
        );
    }
}

// 2. 绕轴旋转
public class OrbitRotation : MonoBehaviour
{
    public Transform center;
    public float orbitSpeed = 30f;
    
    void Update()
    {
        // 绕center的Y轴旋转
        transform.RotateAround(
            center.position,
            Vector3.up,
            orbitSpeed * Time.deltaTime
        );
    }
}

// 3. 限制旋转角度
public class ClampedRotation : MonoBehaviour
{
    public float maxAngle = 45f;
    
    void Update()
    {
        Vector3 euler = transform.eulerAngles;
        
        // 将角度转换到-180到180范围
        float x = euler.x > 180 ? euler.x - 360 : euler.x;
        
        // 限制角度
        x = Mathf.Clamp(x, -maxAngle, maxAngle);
        
        transform.eulerAngles = new Vector3(x, euler.y, euler.z);
    }
}

// 4. 计算两个旋转之间的差异
Quaternion diff = Quaternion.Inverse(rotationA) * rotationB;
diff.ToAngleAxis(out float angle, out Vector3 axis);
```

---

## 13.5 其他常用数学

### 线性插值

```csharp
// 数值插值
float result = Mathf.Lerp(a, b, t);  // a + (b - a) * t

// 向量插值
Vector3 result = Vector3.Lerp(a, b, t);

// 颜色插值
Color result = Color.Lerp(a, b, t);

// 平滑插值（缓入缓出）
float result = Mathf.SmoothStep(a, b, t);

// 弹性插值
float result = Mathf.LerpUnclamped(a, b, t);  // t可以超出0-1
```

### 常用数学函数

```csharp
// 三角函数
float sin = Mathf.Sin(angle * Mathf.Deg2Rad);
float cos = Mathf.Cos(angle * Mathf.Deg2Rad);
float angle = Mathf.Atan2(y, x) * Mathf.Rad2Deg;

// 限制范围
float clamped = Mathf.Clamp(value, min, max);
float clamped01 = Mathf.Clamp01(value);

// 绝对值、符号
float abs = Mathf.Abs(value);
float sign = Mathf.Sign(value);

// 最大最小
float max = Mathf.Max(a, b);
float min = Mathf.Min(a, b);

// 幂运算
float pow = Mathf.Pow(base, exponent);
float sqrt = Mathf.Sqrt(value);

// 取整
int floor = Mathf.FloorToInt(value);
int ceil = Mathf.CeilToInt(value);
int round = Mathf.RoundToInt(value);

// 循环
float repeat = Mathf.Repeat(t, length);  // 0到length循环
float pingPong = Mathf.PingPong(t, length);  // 0到length来回
```

---

## 面试要点总结

### 问题73：向量的点积和叉积有什么用？

**答案要点：**

**点积（Dot Product）：**
- 公式：a·b = |a||b|cos(θ)
- 结果是标量
- 应用：
  - 判断夹角关系（>0同向，=0垂直，<0反向）
  - 计算夹角
  - 判断目标是否在前方/视野内
  - 计算投影

**叉积（Cross Product）：**
- 公式：|a×b| = |a||b|sin(θ)
- 结果是向量，垂直于原向量
- 应用：
  - 计算法向量
  - 判断左右方向
  - 计算旋转轴
  - 计算三角形面积

### 问题74：四元数是什么？为什么用四元数表示旋转？

**答案要点：**

**四元数定义：**
- q = w + xi + yj + zk
- 4个分量表示旋转
- q = cos(θ/2) + sin(θ/2) * axis

**为什么使用四元数：**

| 表示方式 | 优点 | 缺点 |
|----------|------|------|
| 欧拉角 | 直观 | 万向节锁 |
| 旋转矩阵 | 无万向节锁 | 9个数，冗余 |
| 四元数 | 无万向节锁，4个数，插值平滑 | 不直观 |

**万向节锁：**
- 当一个轴旋转90°时，另外两个轴重合
- 丢失一个旋转自由度
- 四元数不存在这个问题

**常用操作：**
- Quaternion.Euler()：从欧拉角创建
- Quaternion.Slerp()：球面插值
- Quaternion.LookRotation()：朝向目标

---

[返回目录](./00_目录.md) | [上一章：网络协议](./12_网络协议.md) | [下一章：动画](./14_动画.md)