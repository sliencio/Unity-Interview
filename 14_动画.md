# 十四、动画

> 本章涵盖问题：
> - Unity动画系统有哪些？各有什么特点？
> - Animator和Animation的区别是什么？
> - 动画融合（Blend Tree）是什么？

---

## 14.1 Unity动画系统概述

### 动画系统演进

```
Unity动画系统发展：

Legacy Animation（旧版）
├─ Animation组件
├─ AnimationClip
└─ 简单直接，适合简单动画

Mecanim（现代版）
├─ Animator组件
├─ Animator Controller
├─ 状态机
├─ Blend Tree
├─ Avatar系统
└─ 功能强大，适合复杂角色动画

Timeline（时间轴）
├─ 过场动画
├─ 多轨道编辑
└─ 适合剧情、CG

Playables API
├─ 底层API
├─ 自定义动画系统
└─ 高度灵活
```

### 各系统对比

| 系统 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| Animation | 简单、轻量 | 功能有限 | 简单动画、UI动画 |
| Animator | 功能强大、状态机 | 复杂、有开销 | 角色动画 |
| Timeline | 可视化编辑 | 运行时修改困难 | 过场动画 |
| Playables | 灵活、可编程 | 学习曲线高 | 自定义系统 |

---

## 14.2 Animation（Legacy）

### 基本使用

```csharp
// Animation组件
Animation anim = GetComponent<Animation>();

// 播放动画
anim.Play("Walk");
anim.Play("Run", PlayMode.StopAll);

// 淡入淡出
anim.CrossFade("Run", 0.3f);

// 混合动画
anim.Blend("Walk", 0.5f);

// 动画控制
anim["Walk"].speed = 2f;      // 播放速度
anim["Walk"].time = 0.5f;     // 当前时间
anim["Walk"].normalizedTime;  // 归一化时间(0-1)
anim["Walk"].wrapMode = WrapMode.Loop;

// 动画事件
AnimationClip clip = anim["Walk"].clip;
AnimationEvent evt = new AnimationEvent();
evt.functionName = "OnFootstep";
evt.time = 0.5f;
clip.AddEvent(evt);
```

### 动画曲线

```csharp
// 通过曲线控制属性
AnimationCurve curve = AnimationCurve.EaseInOut(0, 0, 1, 1);

// 添加关键帧
curve.AddKey(0.5f, 0.8f);

// 采样
float value = curve.Evaluate(time);

// 在动画中使用
AnimationClip clip = new AnimationClip();
clip.SetCurve("", typeof(Transform), "localPosition.x", curve);
```

---

## 14.3 Animator（Mecanim）

### 核心组件

```
Animator系统组成：

┌─────────────────────────────────────────────────────┐
│                    Animator组件                      │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Animator Controller（动画控制器）                   │
│  ┌─────────────────────────────────────────────┐   │
│  │                                             │   │
│  │  Layer 0（Base Layer）                      │   │
│  │  ┌─────────────────────────────────────┐   │   │
│  │  │ State Machine（状态机）              │   │   │
│  │  │ ┌─────┐    ┌─────┐    ┌─────┐      │   │   │
│  │  │ │Idle │───►│Walk │───►│ Run │      │   │   │
│  │  │ └─────┘    └─────┘    └─────┘      │   │   │
│  │  │    ▲                      │        │   │   │
│  │  │    └──────────────────────┘        │   │   │
│  │  └─────────────────────────────────────┘   │   │
│  │                                             │   │
│  │  Layer 1（Upper Body）                      │   │
│  │  └─ 上半身动画覆盖                          │   │
│  │                                             │   │
│  │  Parameters（参数）                          │   │
│  │  ├─ Speed (Float)                           │   │
│  │  ├─ IsGrounded (Bool)                       │   │
│  │  └─ Jump (Trigger)                          │   │
│  │                                             │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  Avatar（骨骼映射）                                  │
│  └─ 人形骨骼标准化                                  │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 基本使用

```csharp
Animator animator = GetComponent<Animator>();

// 设置参数
animator.SetFloat("Speed", moveSpeed);
animator.SetBool("IsGrounded", isGrounded);
animator.SetInteger("State", stateIndex);
animator.SetTrigger("Jump");

// 获取参数
float speed = animator.GetFloat("Speed");
bool grounded = animator.GetBool("IsGrounded");

// 播放状态
animator.Play("Run");
animator.Play("Run", layerIndex, normalizedTime);

// 过渡
animator.CrossFade("Run", 0.2f);
animator.CrossFadeInFixedTime("Run", 0.2f);

// 获取状态信息
AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0);
bool isRunning = stateInfo.IsName("Run");
float normalizedTime = stateInfo.normalizedTime;

// 动画事件（在动画中设置，脚本中接收）
void OnFootstep()
{
    // 播放脚步声
}
```

### 状态机脚本

```csharp
// StateMachineBehaviour：状态机行为脚本
public class AttackState : StateMachineBehaviour
{
    // 进入状态时
    override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        Debug.Log("进入攻击状态");
    }
    
    // 状态更新时（每帧）
    override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        // 状态逻辑
    }
    
    // 退出状态时
    override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        Debug.Log("退出攻击状态");
    }
    
    // 状态机进入时
    override public void OnStateMachineEnter(Animator animator, int stateMachinePathHash)
    {
    }
    
    // 状态机退出时
    override public void OnStateMachineExit(Animator animator, int stateMachinePathHash)
    {
    }
}
```

---

## 14.4 Animation vs Animator

### 详细对比

| 特性 | Animation | Animator |
|------|-----------|----------|
| 组件 | Animation | Animator |
| 控制方式 | 代码直接控制 | 状态机 + 参数 |
| 动画混合 | 简单混合 | Blend Tree |
| 层级 | 不支持 | 支持多层 |
| IK | 不支持 | 支持 |
| 人形动画 | 不支持 | Avatar系统 |
| 性能 | 轻量 | 有一定开销 |
| 复杂度 | 简单 | 复杂 |
| 适用场景 | 简单动画 | 角色动画 |

### 选择建议

```
选择Animation：
├─ UI动画
├─ 简单物体动画（门、开关）
├─ 不需要状态机
└─ 追求轻量

选择Animator：
├─ 角色动画
├─ 需要状态机管理
├─ 需要动画混合
├─ 需要IK
└─ 需要动画重定向
```

---

## 14.5 Blend Tree（动画融合）

### 什么是Blend Tree

```
Blend Tree：根据参数混合多个动画

1D Blend Tree（一维混合）：
┌─────────────────────────────────────────────────────┐
│                                                     │
│  Speed参数: 0 ─────────────────────────────────► 1  │
│             │         │         │         │        │
│           Idle      Walk      Jog       Run        │
│                                                     │
│  Speed=0.3时：Idle和Walk混合                        │
│  Speed=0.7时：Jog和Run混合                          │
│                                                     │
└─────────────────────────────────────────────────────┘

2D Blend Tree（二维混合）：
┌─────────────────────────────────────────────────────┐
│                                                     │
│         Forward                                     │
│            ▲                                        │
│            │    Run_F                               │
│            │      ●                                 │
│   Run_L ●  │        ● Run_R                        │
│  ◄─────────┼──────────────────► Right              │
│            │                                        │
│            │    Run_B                               │
│            ●                                        │
│                                                     │
│  根据(Horizontal, Vertical)参数混合四个方向动画     │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### Blend Tree类型

| 类型 | 参数 | 说明 |
|------|------|------|
| 1D | 1个Float | 线性混合 |
| 2D Simple Directional | 2个Float | 简单方向混合 |
| 2D Freeform Directional | 2个Float | 自由方向混合 |
| 2D Freeform Cartesian | 2个Float | 笛卡尔坐标混合 |
| Direct | 多个Float | 直接控制每个动画权重 |

### 代码控制

```csharp
public class CharacterMovement : MonoBehaviour
{
    private Animator animator;
    
    void Start()
    {
        animator = GetComponent<Animator>();
    }
    
    void Update()
    {
        // 获取输入
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");
        
        // 计算速度
        float speed = new Vector2(horizontal, vertical).magnitude;
        
        // 设置Blend Tree参数
        animator.SetFloat("Speed", speed);
        animator.SetFloat("Horizontal", horizontal);
        animator.SetFloat("Vertical", vertical);
    }
}
```

### 平滑过渡

```csharp
// 使用SmoothDamp平滑参数变化
private float currentSpeed;
private float speedVelocity;

void Update()
{
    float targetSpeed = GetTargetSpeed();
    
    // 平滑过渡
    currentSpeed = Mathf.SmoothDamp(
        currentSpeed, 
        targetSpeed, 
        ref speedVelocity, 
        0.1f  // 平滑时间
    );
    
    animator.SetFloat("Speed", currentSpeed);
}
```

---

## 14.6 动画层（Layers）

### 层的作用

```
动画层：分离不同身体部位的动画

┌─────────────────────────────────────────────────────┐
│ Layer 0: Base Layer（基础层）                        │
│ └─ 全身动画：Idle, Walk, Run                        │
│                                                     │
│ Layer 1: Upper Body（上半身层）                      │
│ └─ 上半身动画：Attack, Reload                       │
│ └─ Avatar Mask: 只影响上半身                        │
│                                                     │
│ Layer 2: Face（面部层）                              │
│ └─ 面部动画：Blink, Talk                            │
│ └─ Avatar Mask: 只影响面部                          │
└─────────────────────────────────────────────────────┘

混合模式：
• Override：覆盖下层
• Additive：叠加到下层
```

### 代码控制层

```csharp
// 设置层权重
animator.SetLayerWeight(1, 1f);  // 上半身层完全启用

// 获取层信息
int layerIndex = animator.GetLayerIndex("Upper Body");
float weight = animator.GetLayerWeight(layerIndex);

// 获取层的状态信息
AnimatorStateInfo info = animator.GetCurrentAnimatorStateInfo(layerIndex);
```

---

## 14.7 IK（反向动力学）

### IK概念

```
正向动力学（FK）：从根骨骼到末端
└─ 肩膀旋转 → 手臂跟随 → 手跟随

反向动力学（IK）：从末端到根骨骼
└─ 手的目标位置 → 计算手臂角度 → 计算肩膀角度
```

### Unity IK使用

```csharp
public class IKController : MonoBehaviour
{
    private Animator animator;
    public Transform lookTarget;
    public Transform leftHandTarget;
    public Transform rightHandTarget;
    
    [Range(0, 1)]
    public float lookWeight = 1f;
    public float handWeight = 1f;
    
    void Start()
    {
        animator = GetComponent<Animator>();
    }
    
    // 必须在OnAnimatorIK中设置IK
    void OnAnimatorIK(int layerIndex)
    {
        if (animator == null) return;
        
        // 头部IK（看向目标）
        if (lookTarget != null)
        {
            animator.SetLookAtWeight(lookWeight);
            animator.SetLookAtPosition(lookTarget.position);
        }
        
        // 左手IK
        if (leftHandTarget != null)
        {
            animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, handWeight);
            animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, handWeight);
            animator.SetIKPosition(AvatarIKGoal.LeftHand, leftHandTarget.position);
            animator.SetIKRotation(AvatarIKGoal.LeftHand, leftHandTarget.rotation);
        }
        
        // 右手IK
        if (rightHandTarget != null)
        {
            animator.SetIKPositionWeight(AvatarIKGoal.RightHand, handWeight);
            animator.SetIKRotationWeight(AvatarIKGoal.RightHand, handWeight);
            animator.SetIKPosition(AvatarIKGoal.RightHand, rightHandTarget.position);
            animator.SetIKRotation(AvatarIKGoal.RightHand, rightHandTarget.rotation);
        }
    }
}
```

### 脚部IK（地面适应）

```csharp
public class FootIK : MonoBehaviour
{
    private Animator animator;
    public LayerMask groundLayer;
    public float footOffset = 0.1f;
    
    void OnAnimatorIK(int layerIndex)
    {
        // 左脚
        Vector3 leftFootPos = animator.GetIKPosition(AvatarIKGoal.LeftFoot);
        if (Physics.Raycast(leftFootPos + Vector3.up, Vector3.down, out RaycastHit hit, 2f, groundLayer))
        {
            Vector3 footPos = hit.point + Vector3.up * footOffset;
            animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, 1f);
            animator.SetIKPosition(AvatarIKGoal.LeftFoot, footPos);
            
            // 脚的旋转适应地面
            Quaternion footRot = Quaternion.FromToRotation(Vector3.up, hit.normal) * 
                                 animator.GetIKRotation(AvatarIKGoal.LeftFoot);
            animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, 1f);
            animator.SetIKRotation(AvatarIKGoal.LeftFoot, footRot);
        }
        
        // 右脚类似...
    }
}
```

---

## 14.8 动画优化

### 性能优化建议

```csharp
// 1. 使用Culling Mode
// - Always Animate：始终更新（默认）
// - Cull Update Transforms：不可见时不更新骨骼
// - Cull Completely：不可见时完全停止

// 2. 减少骨骼数量
// 移动端建议：30-50根骨骼

// 3. 使用动画压缩
// Animation Compression设置

// 4. 避免频繁GetComponent
private Animator animator;
void Start()
{
    animator = GetComponent<Animator>();
}

// 5. 使用Hash代替字符串
private static readonly int SpeedHash = Animator.StringToHash("Speed");
private static readonly int JumpHash = Animator.StringToHash("Jump");

void Update()
{
    animator.SetFloat(SpeedHash, speed);  // 比SetFloat("Speed", speed)快
    animator.SetTrigger(JumpHash);
}

// 6. 合理使用层
// 不需要的层设置权重为0

// 7. 使用Generic代替Humanoid（如果不需要重定向）
```

---

## 面试要点总结

### 问题75：Unity动画系统有哪些？各有什么特点？

**答案要点：**

| 系统 | 特点 | 适用场景 |
|------|------|----------|
| Animation | 简单轻量，代码直接控制 | UI动画、简单物体 |
| Animator | 状态机、Blend Tree、IK | 角色动画 |
| Timeline | 可视化多轨道编辑 | 过场动画 |
| Playables | 底层API，高度灵活 | 自定义系统 |

### 问题76：Animator和Animation的区别是什么？

**答案要点：**

| 特性 | Animation | Animator |
|------|-----------|----------|
| 控制方式 | 代码直接控制 | 状态机 + 参数 |
| 动画混合 | 简单 | Blend Tree |
| 层级 | 不支持 | 支持 |
| IK | 不支持 | 支持 |
| 性能 | 轻量 | 有开销 |
| 适用 | 简单动画 | 角色动画 |

### 问题77：动画融合（Blend Tree）是什么？

**答案要点：**

1. **定义**：根据参数混合多个动画

2. **类型**：
   - 1D：一个参数，线性混合
   - 2D：两个参数，方向混合

3. **应用**：
   - 移动动画（Idle→Walk→Run）
   - 方向动画（前后左右）

4. **优势**：
   - 平滑过渡
   - 减少动画数量
   - 动态混合

---

[返回目录](./00_目录.md) | [上一章：数学](./13_数学.md) | [下一章：性能优化](./15_性能优化.md)