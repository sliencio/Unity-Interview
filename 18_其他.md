# 十八、其他

> 本章涵盖问题：
> - Unity的序列化机制是怎样的？
> - ScriptableObject是什么？有什么用途？
> - Unity的多线程有哪些方式？
> - 如何实现游戏存档系统？
> - Unity的生命周期函数执行顺序是什么？

---

## 18.1 Unity序列化

### 序列化规则

```csharp
// Unity可以序列化的类型：
// 1. 公共字段
public int publicField;  // ✓ 序列化

// 2. 带[SerializeField]的私有字段
[SerializeField]
private int privateField;  // ✓ 序列化

// 3. 基本类型
public int intValue;      // ✓
public float floatValue;  // ✓
public string stringValue;// ✓
public bool boolValue;    // ✓

// 4. Unity内置类型
public Vector3 position;  // ✓
public Color color;       // ✓
public AnimationCurve curve; // ✓

// 5. 可序列化的自定义类/结构体
[System.Serializable]
public class CustomData
{
    public int value;
}
public CustomData data;   // ✓

// 6. 数组和List
public int[] intArray;    // ✓
public List<int> intList; // ✓

// 7. UnityEngine.Object引用
public GameObject prefab; // ✓
public Material material; // ✓
```

### 不能序列化的类型

```csharp
// 1. 静态字段
public static int staticField;  // ✗

// 2. 常量
public const int constField = 10;  // ✗

// 3. 只读字段
public readonly int readonlyField;  // ✗

// 4. 属性
public int Property { get; set; }  // ✗

// 5. Dictionary
public Dictionary<string, int> dict;  // ✗

// 6. 接口类型
public IEnumerable<int> enumerable;  // ✗

// 7. 委托
public Action callback;  // ✗

// 8. 多维数组
public int[,] multiArray;  // ✗
```

### 序列化Dictionary的解决方案

```csharp
[System.Serializable]
public class SerializableDictionary<TKey, TValue> : ISerializationCallbackReceiver
{
    [SerializeField]
    private List<TKey> keys = new List<TKey>();
    
    [SerializeField]
    private List<TValue> values = new List<TValue>();
    
    private Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>();
    
    public TValue this[TKey key]
    {
        get => dictionary[key];
        set => dictionary[key] = value;
    }
    
    public void OnBeforeSerialize()
    {
        keys.Clear();
        values.Clear();
        foreach (var kvp in dictionary)
        {
            keys.Add(kvp.Key);
            values.Add(kvp.Value);
        }
    }
    
    public void OnAfterDeserialize()
    {
        dictionary.Clear();
        for (int i = 0; i < keys.Count; i++)
        {
            dictionary[keys[i]] = values[i];
        }
    }
}

// 使用
[SerializeField]
private SerializableDictionary<string, int> scores;
```

---

## 18.2 ScriptableObject

### 什么是ScriptableObject

```csharp
// ScriptableObject是可以存储数据的资源文件
// 不依附于场景中的GameObject

[CreateAssetMenu(fileName = "NewItem", menuName = "Game/Item Data")]
public class ItemData : ScriptableObject
{
    public string itemName;
    public Sprite icon;
    public int price;
    public string description;
}

// 在Project窗口右键 -> Create -> Game -> Item Data
```

### 用途

```csharp
// 1. 配置数据
[CreateAssetMenu]
public class GameConfig : ScriptableObject
{
    public float playerSpeed = 5f;
    public int maxHealth = 100;
    public float gravity = -9.8f;
}

// 2. 共享数据（多个对象引用同一份数据）
public class Enemy : MonoBehaviour
{
    public EnemyData data;  // 多个敌人共享同一份数据
    
    void Start()
    {
        health = data.maxHealth;
        speed = data.moveSpeed;
    }
}

// 3. 事件通道
[CreateAssetMenu]
public class GameEvent : ScriptableObject
{
    private List<GameEventListener> listeners = new List<GameEventListener>();
    
    public void Raise()
    {
        for (int i = listeners.Count - 1; i >= 0; i--)
        {
            listeners[i].OnEventRaised();
        }
    }
    
    public void RegisterListener(GameEventListener listener)
    {
        listeners.Add(listener);
    }
    
    public void UnregisterListener(GameEventListener listener)
    {
        listeners.Remove(listener);
    }
}

// 4. 技能/物品数据库
[CreateAssetMenu]
public class ItemDatabase : ScriptableObject
{
    public List<ItemData> items;
    
    public ItemData GetItem(int id)
    {
        return items.Find(item => item.id == id);
    }
}
```

### ScriptableObject vs MonoBehaviour

| 特性 | ScriptableObject | MonoBehaviour |
|------|------------------|---------------|
| 存在位置 | Project（资源） | Scene（场景） |
| 生命周期 | 独立于场景 | 依赖GameObject |
| 实例化 | CreateInstance | AddComponent |
| 用途 | 数据存储 | 行为逻辑 |
| 序列化 | 作为资源保存 | 随场景保存 |

---

## 18.3 Unity多线程

### 多线程方式

```csharp
// 1. System.Threading.Thread
using System.Threading;

void StartThread()
{
    Thread thread = new Thread(WorkerMethod);
    thread.Start();
}

void WorkerMethod()
{
    // 后台工作
    // 注意：不能调用Unity API！
}

// 2. ThreadPool
ThreadPool.QueueUserWorkItem(state =>
{
    // 后台工作
});

// 3. Task（推荐）
using System.Threading.Tasks;

async void DoAsyncWork()
{
    int result = await Task.Run(() =>
    {
        // 后台计算
        return HeavyCalculation();
    });
    
    // 回到主线程，可以使用Unity API
    Debug.Log(result);
}

// 4. Job System（Unity推荐）
using Unity.Jobs;
using Unity.Collections;

public struct MyJob : IJob
{
    public NativeArray<float> data;
    
    public void Execute()
    {
        for (int i = 0; i < data.Length; i++)
        {
            data[i] *= 2;
        }
    }
}

void RunJob()
{
    NativeArray<float> data = new NativeArray<float>(100, Allocator.TempJob);
    
    MyJob job = new MyJob { data = data };
    JobHandle handle = job.Schedule();
    handle.Complete();
    
    data.Dispose();
}
```

### 主线程同步

```csharp
// 在子线程中需要调用Unity API时，需要同步到主线程

public class MainThreadDispatcher : MonoBehaviour
{
    private static readonly Queue<Action> actions = new Queue<Action>();
    private static MainThreadDispatcher instance;
    
    void Awake()
    {
        instance = this;
    }
    
    void Update()
    {
        lock (actions)
        {
            while (actions.Count > 0)
            {
                actions.Dequeue()?.Invoke();
            }
        }
    }
    
    public static void RunOnMainThread(Action action)
    {
        lock (actions)
        {
            actions.Enqueue(action);
        }
    }
}

// 使用
Task.Run(() =>
{
    // 后台计算
    int result = HeavyCalculation();
    
    // 回到主线程更新UI
    MainThreadDispatcher.RunOnMainThread(() =>
    {
        resultText.text = result.ToString();
    });
});
```

### 多线程注意事项

```csharp
// 1. Unity API只能在主线程调用
// 以下在子线程中会报错：
// - transform.position
// - GetComponent<T>()
// - Instantiate()
// - Debug.Log()（某些版本可以）

// 2. 使用线程安全的集合
using System.Collections.Concurrent;
ConcurrentQueue<int> queue = new ConcurrentQueue<int>();
ConcurrentDictionary<string, int> dict = new ConcurrentDictionary<string, int>();

// 3. 使用锁保护共享数据
private readonly object lockObj = new object();
private int sharedData;

void ThreadSafeMethod()
{
    lock (lockObj)
    {
        sharedData++;
    }
}

// 4. 使用Interlocked进行原子操作
private int counter;
Interlocked.Increment(ref counter);
```

---

## 18.4 游戏存档系统

### JSON存档

```csharp
[System.Serializable]
public class SaveData
{
    public int level;
    public int score;
    public float playTime;
    public Vector3Serializable playerPosition;
    public List<string> unlockedItems;
}

// Vector3不能直接序列化为JSON
[System.Serializable]
public struct Vector3Serializable
{
    public float x, y, z;
    
    public Vector3Serializable(Vector3 v)
    {
        x = v.x; y = v.y; z = v.z;
    }
    
    public Vector3 ToVector3() => new Vector3(x, y, z);
}

public class SaveManager
{
    private static string SavePath => 
        Path.Combine(Application.persistentDataPath, "save.json");
    
    public static void Save(SaveData data)
    {
        string json = JsonUtility.ToJson(data, true);
        File.WriteAllText(SavePath, json);
    }
    
    public static SaveData Load()
    {
        if (File.Exists(SavePath))
        {
            string json = File.ReadAllText(SavePath);
            return JsonUtility.FromJson<SaveData>(json);
        }
        return new SaveData();
    }
    
    public static void Delete()
    {
        if (File.Exists(SavePath))
        {
            File.Delete(SavePath);
        }
    }
}
```

### PlayerPrefs存档

```csharp
// 适合简单数据
public class SimplePrefs
{
    public static void SaveInt(string key, int value)
    {
        PlayerPrefs.SetInt(key, value);
        PlayerPrefs.Save();
    }
    
    public static int LoadInt(string key, int defaultValue = 0)
    {
        return PlayerPrefs.GetInt(key, defaultValue);
    }
    
    // 存储复杂对象
    public static void SaveObject<T>(string key, T obj)
    {
        string json = JsonUtility.ToJson(obj);
        PlayerPrefs.SetString(key, json);
        PlayerPrefs.Save();
    }
    
    public static T LoadObject<T>(string key) where T : new()
    {
        string json = PlayerPrefs.GetString(key, "");
        if (string.IsNullOrEmpty(json))
            return new T();
        return JsonUtility.FromJson<T>(json);
    }
}
```

### 二进制存档（加密）

```csharp
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security.Cryptography;

public class BinarySaveManager
{
    private static readonly byte[] Key = { /* 32字节密钥 */ };
    private static readonly byte[] IV = { /* 16字节IV */ };
    
    public static void Save(SaveData data, string filename)
    {
        string path = Path.Combine(Application.persistentDataPath, filename);
        
        using (FileStream fs = new FileStream(path, FileMode.Create))
        using (Aes aes = Aes.Create())
        {
            aes.Key = Key;
            aes.IV = IV;
            
            using (CryptoStream cs = new CryptoStream(fs, 
                aes.CreateEncryptor(), CryptoStreamMode.Write))
            {
                BinaryFormatter bf = new BinaryFormatter();
                bf.Serialize(cs, data);
            }
        }
    }
    
    public static SaveData Load(string filename)
    {
        string path = Path.Combine(Application.persistentDataPath, filename);
        
        if (!File.Exists(path))
            return null;
        
        using (FileStream fs = new FileStream(path, FileMode.Open))
        using (Aes aes = Aes.Create())
        {
            aes.Key = Key;
            aes.IV = IV;
            
            using (CryptoStream cs = new CryptoStream(fs, 
                aes.CreateDecryptor(), CryptoStreamMode.Read))
            {
                BinaryFormatter bf = new BinaryFormatter();
                return (SaveData)bf.Deserialize(cs);
            }
        }
    }
}
```

---

## 18.5 Unity生命周期

### 完整生命周期顺序

```
Unity脚本生命周期：

┌─────────────────────────────────────────────────────┐
│                    初始化                           │
├─────────────────────────────────────────────────────┤
│ Awake()           - 脚本实例化时（即使禁用）        │
│ OnEnable()        - 对象启用时                      │
│ Reset()           - 编辑器中重置组件时              │
│ Start()           - 第一次Update前（仅启用时）      │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    物理循环                         │
├─────────────────────────────────────────────────────┤
│ FixedUpdate()     - 固定时间间隔                    │
│ (内部物理更新)                                      │
│ OnTriggerXXX()    - 触发器回调                      │
│ OnCollisionXXX()  - 碰撞回调                        │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    输入事件                         │
├─────────────────────────────────────────────────────┤
│ OnMouseXXX()      - 鼠标事件                        │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    游戏逻辑                         │
├─────────────────────────────────────────────────────┤
│ Update()          - 每帧调用                        │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    协程                             │
├─────────────────────────────────────────────────────┤
│ yield null        - Update后                        │
│ yield WaitForXXX  - 各种等待                        │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    动画                             │
├─────────────────────────────────────────────────────┤
│ (内部动画更新)                                      │
│ OnAnimatorMove()  - 动画移动回调                    │
│ OnAnimatorIK()    - IK回调                          │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    后期更新                         │
├─────────────────────────────────────────────────────┤
│ LateUpdate()      - Update后调用                    │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    渲染                             │
├─────────────────────────────────────────────────────┤
│ OnWillRenderObject()                                │
│ OnPreCull()                                         │
│ OnBecameVisible()                                   │
│ OnBecameInvisible()                                 │
│ OnPreRender()                                       │
│ OnRenderObject()                                    │
│ OnPostRender()                                      │
│ OnRenderImage()                                     │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    GUI                              │
├─────────────────────────────────────────────────────┤
│ OnGUI()           - GUI渲染（可能多次）             │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    帧结束                           │
├─────────────────────────────────────────────────────┤
│ yield WaitForEndOfFrame                             │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    暂停/退出                        │
├─────────────────────────────────────────────────────┤
│ OnApplicationPause()                                │
│ OnApplicationFocus()                                │
│ OnApplicationQuit()                                 │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    销毁                             │
├─────────────────────────────────────────────────────┤
│ OnDisable()       - 对象禁用时                      │
│ OnDestroy()       - 对象销毁时                      │
└─────────────────────────────────────────────────────┘
```

### 常用生命周期函数

```csharp
public class LifecycleExample : MonoBehaviour
{
    // 初始化（最早，即使脚本禁用也会调用）
    void Awake()
    {
        // 获取组件引用
        // 初始化不依赖其他对象的数据
    }
    
    // 启用时
    void OnEnable()
    {
        // 订阅事件
        EventManager.OnGameStart += HandleGameStart;
    }
    
    // 第一帧Update前（仅启用时）
    void Start()
    {
        // 初始化依赖其他对象的数据
        // 此时其他对象的Awake已执行完毕
    }
    
    // 固定时间间隔（物理）
    void FixedUpdate()
    {
        // 物理相关操作
        rb.AddForce(force);
    }
    
    // 每帧
    void Update()
    {
        // 游戏逻辑
        // 输入处理
    }
    
    // Update后
    void LateUpdate()
    {
        // 相机跟随
        // 需要在所有Update后执行的逻辑
    }
    
    // 禁用时
    void OnDisable()
    {
        // 取消订阅事件
        EventManager.OnGameStart -= HandleGameStart;
    }
    
    // 销毁时
    void OnDestroy()
    {
        // 清理资源
    }
}
```

---

## 面试要点总结

### 问题89：Unity的序列化机制是怎样的？

**答案要点：**

1. **可序列化**：
   - 公共字段
   - [SerializeField]私有字段
   - 基本类型、Unity类型
   - [Serializable]自定义类
   - 数组和List

2. **不可序列化**：
   - 静态、const、readonly
   - 属性
   - Dictionary
   - 委托、接口

### 问题90：ScriptableObject是什么？有什么用途？

**答案要点：**

1. **定义**：可存储数据的资源文件，独立于场景

2. **用途**：
   - 配置数据
   - 共享数据
   - 事件通道
   - 数据库

### 问题91：Unity的多线程有哪些方式？

**答案要点：**

1. **方式**：
   - Thread
   - ThreadPool
   - Task（推荐）
   - Job System（Unity推荐）

2. **注意**：
   - Unity API只能在主线程调用
   - 使用线程安全集合
   - 需要同步回主线程

### 问题92：如何实现游戏存档系统？

**答案要点：**

1. **方式**：
   - JSON（JsonUtility）
   - PlayerPrefs（简单数据）
   - 二进制（可加密）

2. **路径**：Application.persistentDataPath

### 问题93：Unity的生命周期函数执行顺序是什么？

**答案要点：**

```
Awake → OnEnable → Start → FixedUpdate → Update → LateUpdate → OnDisable → OnDestroy
```

- Awake：最早，即使禁用也调用
- Start：第一帧Update前
- FixedUpdate：固定间隔，物理
- Update：每帧
- LateUpdate：Update后

---

[返回目录](./00_目录.md) | [上一章：设计模式](./17_设计模式.md)