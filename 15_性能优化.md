# 十五、性能优化

> 本章涵盖问题：
> - Unity性能优化的主要方向有哪些？
> - 如何使用Profiler进行性能分析？
> - 常见的性能瓶颈有哪些？如何解决？
> - 移动端优化有哪些特殊考虑？

---

## 15.1 性能优化概述

### 优化方向

```
Unity性能优化主要方向：

┌─────────────────────────────────────────────────────┐
│                    性能优化                          │
├─────────────────────────────────────────────────────┤
│                                                     │
│  CPU优化                                            │
│  ├─ 脚本优化                                        │
│  ├─ 物理优化                                        │
│  ├─ 动画优化                                        │
│  └─ GC优化                                          │
│                                                     │
│  GPU优化                                            │
│  ├─ 渲染优化（Draw Call、Overdraw）                 │
│  ├─ Shader优化                                      │
│  └─ 纹理优化                                        │
│                                                     │
│  内存优化                                           │
│  ├─ 资源管理                                        │
│  ├─ 对象池                                          │
│  └─ 内存泄漏检测                                    │
│                                                     │
│  加载优化                                           │
│  ├─ 异步加载                                        │
│  ├─ 资源预加载                                      │
│  └─ 场景管理                                        │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 优化原则

```
1. 先测量，后优化
   └─ 使用Profiler找到真正的瓶颈

2. 优化热点代码
   └─ 80%的时间花在20%的代码上

3. 空间换时间
   └─ 缓存计算结果、对象池

4. 减少不必要的工作
   └─ 视锥剔除、LOD、遮挡剔除

5. 批处理
   └─ 合批、批量操作
```

---

## 15.2 Profiler使用

### CPU Profiler

```csharp
// 代码中标记Profiler区域
using UnityEngine.Profiling;

void Update()
{
    Profiler.BeginSample("MyExpensiveOperation");
    // 需要分析的代码
    DoExpensiveWork();
    Profiler.EndSample();
}

// 深度分析
[System.Diagnostics.Conditional("ENABLE_PROFILER")]
void ProfiledMethod()
{
    Profiler.BeginSample("ProfiledMethod");
    // ...
    Profiler.EndSample();
}
```

### Memory Profiler

```csharp
// 获取内存信息
long totalMemory = Profiler.GetTotalAllocatedMemoryLong();
long usedHeap = Profiler.usedHeapSizeLong;
long monoHeap = Profiler.GetMonoHeapSizeLong();
long monoUsed = Profiler.GetMonoUsedSizeLong();

// 记录内存快照
// 使用Memory Profiler包拍摄快照
```

### 常见Profiler指标

| 指标 | 说明 | 建议值 |
|------|------|--------|
| FPS | 帧率 | 移动端30+，PC 60+ |
| CPU Time | CPU每帧耗时 | <33ms(30fps) |
| GPU Time | GPU每帧耗时 | <33ms(30fps) |
| Draw Calls | 绘制调用数 | 移动端<200 |
| Triangles | 三角形数 | 移动端<100K |
| SetPass Calls | Shader切换数 | 越少越好 |
| GC Alloc | 每帧GC分配 | 0或极少 |

---

## 15.3 CPU优化

### 脚本优化

```csharp
// 1. 缓存组件引用
// 不好
void Update()
{
    GetComponent<Rigidbody>().velocity = Vector3.zero;  // 每帧GetComponent
}

// 好
private Rigidbody rb;
void Start()
{
    rb = GetComponent<Rigidbody>();
}
void Update()
{
    rb.velocity = Vector3.zero;
}

// 2. 避免在Update中使用Find
// 不好
void Update()
{
    GameObject.Find("Player").transform.position;  // 每帧查找
}

// 好
private Transform playerTransform;
void Start()
{
    playerTransform = GameObject.Find("Player").transform;
}

// 3. 使用对象池
// 不好
void Fire()
{
    Instantiate(bulletPrefab);  // 频繁创建
}

// 好
void Fire()
{
    var bullet = bulletPool.Get();  // 从池中获取
}

// 4. 减少Update调用
// 不好：每个敌人都有Update
class Enemy : MonoBehaviour
{
    void Update() { }  // 1000个敌人 = 1000次Update调用
}

// 好：使用管理器统一更新
class EnemyManager : MonoBehaviour
{
    List<Enemy> enemies;
    void Update()
    {
        foreach (var enemy in enemies)
            enemy.CustomUpdate();  // 一次Update调用
    }
}

// 5. 使用协程分帧处理
IEnumerator ProcessLargeData()
{
    for (int i = 0; i < largeData.Count; i++)
    {
        ProcessItem(largeData[i]);
        
        if (i % 100 == 0)  // 每处理100个暂停一帧
            yield return null;
    }
}

// 6. 避免字符串操作
// 不好
string name = "Player" + id.ToString();  // 产生GC

// 好
StringBuilder sb = new StringBuilder();
sb.Append("Player");
sb.Append(id);
string name = sb.ToString();

// 或使用字符串插值（某些情况下更优）
string name = $"Player{id}";
```

### 物理优化

```csharp
// 1. 减少物理更新频率
// Edit > Project Settings > Time
// Fixed Timestep: 0.02 (50Hz) → 0.04 (25Hz)

// 2. 使用简单碰撞体
// 优先使用：Box、Sphere、Capsule
// 避免使用：Mesh Collider

// 3. 设置合理的碰撞层
// Edit > Project Settings > Physics
// 禁用不需要碰撞的层之间的检测

// 4. 使用触发器代替碰撞
// 触发器比碰撞检测更轻量

// 5. 减少Rigidbody数量
// 静态物体不要加Rigidbody
// 或设置为Kinematic

// 6. 使用OverlapSphere代替多次Raycast
Collider[] results = new Collider[10];
int count = Physics.OverlapSphereNonAlloc(position, radius, results);
```

### 动画优化

```csharp
// 1. 使用Culling Mode
animator.cullingMode = AnimatorCullingMode.CullCompletely;

// 2. 减少骨骼数量
// 移动端：30-50根

// 3. 使用动画压缩
// Animation Compression: Optimal

// 4. 使用Hash代替字符串
private static readonly int SpeedHash = Animator.StringToHash("Speed");
animator.SetFloat(SpeedHash, speed);

// 5. 禁用不需要的层
animator.SetLayerWeight(1, 0);
```

---

## 15.4 GPU优化

### 渲染优化

```csharp
// 1. 减少Draw Call
// - 静态合批
// - 动态合批
// - GPU Instancing
// - SRP Batcher

// 2. 使用LOD
LODGroup lodGroup = GetComponent<LODGroup>();
// 设置不同距离的模型

// 3. 使用遮挡剔除
// Window > Rendering > Occlusion Culling
// 烘焙遮挡数据

// 4. 减少Overdraw
// - 减少半透明物体
// - 使用Alpha Test代替Alpha Blend
// - 合理设置渲染顺序

// 5. 减少实时光照
// - 使用烘焙光照
// - 限制实时光源数量
// - 使用Light Probes
```

### Shader优化

```csharp
// 1. 使用移动端友好的Shader
// - Mobile/Diffuse
// - Mobile/Bumped Diffuse

// 2. 减少Shader复杂度
// - 减少数学运算
// - 减少纹理采样
// - 避免分支语句

// 3. 使用Shader LOD
Shader.globalMaximumLOD = 200;  // 移动端使用低LOD

// 4. 避免实时阴影
// 或使用简单的阴影设置
QualitySettings.shadowResolution = ShadowResolution.Low;
QualitySettings.shadowDistance = 20f;
```

### 纹理优化

```csharp
// 1. 使用合适的压缩格式
// iOS: PVRTC/ASTC
// Android: ETC2/ASTC

// 2. 使用Mipmap
// 3D物体纹理开启Mipmap
// UI纹理关闭Mipmap

// 3. 控制纹理大小
// 移动端：最大1024x1024
// 根据实际需要选择

// 4. 使用图集
// 减少纹理切换
// 提高合批效率
```

---

## 15.5 内存优化

### 资源管理

```csharp
// 1. 及时卸载不用的资源
Resources.UnloadUnusedAssets();

// 2. 使用AssetBundle
// 按需加载，及时卸载
bundle.Unload(true);

// 3. 使用Addressables
// 自动引用计数
Addressables.Release(handle);

// 4. 压缩资源
// 纹理压缩、音频压缩、网格压缩
```

### 对象池

```csharp
public class ObjectPool<T> where T : class, new()
{
    private Stack<T> pool = new Stack<T>();
    private Func<T> createFunc;
    private Action<T> resetAction;
    
    public ObjectPool(Func<T> create, Action<T> reset, int initialSize = 10)
    {
        createFunc = create;
        resetAction = reset;
        
        for (int i = 0; i < initialSize; i++)
        {
            pool.Push(createFunc());
        }
    }
    
    public T Get()
    {
        return pool.Count > 0 ? pool.Pop() : createFunc();
    }
    
    public void Return(T obj)
    {
        resetAction?.Invoke(obj);
        pool.Push(obj);
    }
}

// 使用
var bulletPool = new ObjectPool<Bullet>(
    () => new Bullet(),
    bullet => bullet.Reset(),
    100
);
```

### GC优化

```csharp
// 1. 避免在Update中分配内存
// 不好
void Update()
{
    var list = new List<int>();  // 每帧分配
}

// 好
private List<int> list = new List<int>();
void Update()
{
    list.Clear();  // 复用
}

// 2. 使用struct代替class（小型数据）
struct DamageInfo
{
    public int damage;
    public Vector3 position;
}

// 3. 使用StringBuilder
private StringBuilder sb = new StringBuilder();

// 4. 缓存数组
private Collider[] hitResults = new Collider[10];
void CheckHits()
{
    int count = Physics.OverlapSphereNonAlloc(pos, radius, hitResults);
}

// 5. 使用foreach时注意
// List<T>的foreach不产生GC（Unity 5.5+）
// 但自定义集合可能产生GC
```

---

## 15.6 移动端优化

### 特殊考虑

```
移动端限制：
├─ CPU较弱
├─ GPU填充率有限
├─ 内存有限
├─ 带宽有限
├─ 发热和耗电
└─ 屏幕分辨率高

优化目标：
├─ 30fps稳定
├─ Draw Call < 200
├─ 三角形 < 100K
├─ 纹理内存 < 50MB
└─ 总内存 < 200MB
```

### 移动端优化清单

```csharp
// 1. 降低分辨率
Screen.SetResolution(1280, 720, true);

// 2. 降低质量设置
QualitySettings.SetQualityLevel(0);  // 最低质量

// 3. 关闭不必要的效果
// - 实时阴影
// - 后处理
// - 抗锯齿

// 4. 使用简化的Shader
// Mobile/Diffuse等

// 5. 减少粒子数量
particleSystem.maxParticles = 50;

// 6. 使用纹理压缩
// ASTC格式

// 7. 控制帧率
Application.targetFrameRate = 30;

// 8. 使用GPU Instancing
// 大量相同物体

// 9. 减少物理计算
Physics.autoSimulation = false;
// 手动控制物理更新频率

// 10. 使用Light Probes代替实时光照
```

### 发热控制

```csharp
// 1. 限制帧率
Application.targetFrameRate = 30;

// 2. 动态调整质量
void Update()
{
    float fps = 1f / Time.deltaTime;
    if (fps < 25)
    {
        // 降低质量
        QualitySettings.DecreaseLevel();
    }
}

// 3. 减少后台工作
// 暂停时降低更新频率
void OnApplicationPause(bool pause)
{
    if (pause)
    {
        Application.targetFrameRate = 10;
    }
    else
    {
        Application.targetFrameRate = 30;
    }
}
```

---

## 15.7 加载优化

### 异步加载

```csharp
// 1. 异步加载场景
IEnumerator LoadSceneAsync(string sceneName)
{
    AsyncOperation operation = SceneManager.LoadSceneAsync(sceneName);
    operation.allowSceneActivation = false;
    
    while (operation.progress < 0.9f)
    {
        float progress = operation.progress / 0.9f;
        UpdateLoadingBar(progress);
        yield return null;
    }
    
    // 加载完成，激活场景
    operation.allowSceneActivation = true;
}

// 2. 异步加载资源
IEnumerator LoadResourceAsync()
{
    ResourceRequest request = Resources.LoadAsync<GameObject>("Prefab");
    yield return request;
    
    GameObject prefab = request.asset as GameObject;
}

// 3. 分帧加载
IEnumerator LoadItemsOverFrames(List<ItemData> items)
{
    int itemsPerFrame = 10;
    
    for (int i = 0; i < items.Count; i++)
    {
        CreateItem(items[i]);
        
        if ((i + 1) % itemsPerFrame == 0)
        {
            yield return null;  // 每10个暂停一帧
        }
    }
}
```

### 预加载

```csharp
public class PreloadManager : MonoBehaviour
{
    private Dictionary<string, Object> preloadedAssets = new Dictionary<string, Object>();
    
    public IEnumerator PreloadAssets(string[] assetPaths)
    {
        foreach (var path in assetPaths)
        {
            var request = Resources.LoadAsync(path);
            yield return request;
            preloadedAssets[path] = request.asset;
        }
    }
    
    public T GetPreloaded<T>(string path) where T : Object
    {
        if (preloadedAssets.TryGetValue(path, out Object asset))
        {
            return asset as T;
        }
        return null;
    }
}
```

---

## 面试要点总结

### 问题78：Unity性能优化的主要方向有哪些？

**答案要点：**

1. **CPU优化**：脚本、物理、动画、GC
2. **GPU优化**：Draw Call、Overdraw、Shader、纹理
3. **内存优化**：资源管理、对象池、内存泄漏
4. **加载优化**：异步加载、预加载

### 问题79：如何使用Profiler进行性能分析？

**答案要点：**

1. **CPU Profiler**：分析脚本、物理、渲染耗时
2. **Memory Profiler**：分析内存使用、GC
3. **代码标记**：Profiler.BeginSample/EndSample
4. **关注指标**：FPS、CPU Time、GC Alloc、Draw Calls

### 问题80：常见的性能瓶颈有哪些？如何解决？

**答案要点：**

| 瓶颈 | 解决方案 |
|------|----------|
| Draw Call过多 | 合批、GPU Instancing |
| GC频繁 | 对象池、避免临时分配 |
| 脚本耗时 | 缓存、减少Update |
| 物理耗时 | 简化碰撞体、减少检测 |
| 内存过大 | 压缩资源、及时卸载 |

### 问题81：移动端优化有哪些特殊考虑？

**答案要点：**

1. **目标**：30fps、DC<200、三角形<100K
2. **措施**：
   - 降低分辨率
   - 使用纹理压缩（ASTC）
   - 简化Shader
   - 关闭实时阴影
   - 限制帧率
3. **发热控制**：动态调整质量

---

[返回目录](./00_目录.md) | [上一章：动画](./14_动画.md) | [下一章：JIT内联](./16_JIT内联.md)