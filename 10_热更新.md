# 十、热更新

> 本章涵盖问题：
> - 什么是热更新？为什么需要热更新？
> - 热更新的实现方案有哪些？
> - Lua热更新的原理是什么？

---

## 10.1 热更新概述

### 什么是热更新

```
热更新 = 不重新安装App的情况下更新游戏内容

传统更新流程：
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 开发新版 │ → │ 提交商店 │ → │ 审核通过 │ → │ 用户更新 │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                   ↓
              耗时1-7天

热更新流程：
┌─────────┐    ┌─────────┐    ┌─────────┐
│ 开发补丁 │ → │ 上传CDN │ → │ 用户下载 │
└─────────┘    └─────────┘    └─────────┘
                   ↓
              即时生效
```

### 为什么需要热更新

| 原因 | 说明 |
|------|------|
| 快速修复Bug | 紧急问题无需等待审核 |
| 频繁更新内容 | 活动、关卡、配置等 |
| 减少包体大小 | 首包小，按需下载 |
| A/B测试 | 不同用户不同版本 |
| 绕过审核 | 某些内容不适合审核 |

### 热更新的限制

```
iOS限制：
• 禁止下载可执行代码（JIT）
• 允许下载解释执行的脚本（Lua、JS）
• 允许下载资源（图片、音频、配置）

Android限制：
• 相对宽松
• 可以下载并执行代码（但有安全风险）

Unity限制：
• C#代码编译为IL，无法直接热更
• 需要使用特殊方案（Lua、ILRuntime、HybridCLR）
```

---

## 10.2 热更新方案对比

### 主流方案

| 方案 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| **Lua** | 解释执行 | 成熟稳定，iOS支持 | 需要学习Lua，性能较低 |
| **ILRuntime** | IL解释器 | 纯C#开发 | 性能较低，部分特性不支持 |
| **HybridCLR** | IL2CPP扩展 | 原生性能，完整C# | 较新，iOS需要特殊处理 |
| **Puerts** | TypeScript/JS | 前端友好 | 生态较小 |

### 方案选择

```
选择建议：

新项目：
├─ 追求性能 → HybridCLR
├─ 追求稳定 → Lua (xLua/ToLua)
└─ 前端团队 → Puerts

老项目迁移：
├─ 已有Lua → 继续Lua
└─ 纯C#项目 → ILRuntime或HybridCLR
```

---

## 10.3 Lua热更新

### 基本原理

```
Lua热更新原理：

1. Lua是解释型语言
   ┌─────────────────────────────────────┐
   │ Lua源码 (.lua)                      │
   │         ↓                           │
   │ Lua虚拟机 (C语言实现)               │
   │         ↓                           │
   │ 解释执行                            │
   └─────────────────────────────────────┘

2. Lua虚拟机嵌入Unity
   ┌─────────────────────────────────────┐
   │ Unity (C#)                          │
   │ ┌─────────────────────────────────┐ │
   │ │ Lua虚拟机 (作为插件)            │ │
   │ │ ├─ 执行Lua脚本                  │ │
   │ │ └─ 与C#交互                     │ │
   │ └─────────────────────────────────┘ │
   └─────────────────────────────────────┘

3. 热更新流程
   ┌─────────────────────────────────────┐
   │ 服���器                              │
   │ └─ 新版Lua脚本                      │
   │         ↓ 下载                      │
   │ 客户端                              │
   │ └─ 替换本地Lua脚本                  │
   │         ↓ 重新加载                  │
   │ Lua虚拟机执行新脚本                 │
   └─────────────────────────────────────┘
```

### xLua示例

```csharp
// C#端：初始化Lua环境
using XLua;

public class LuaManager : MonoBehaviour
{
    private LuaEnv luaEnv;
    
    void Start()
    {
        // 创建Lua环境
        luaEnv = new LuaEnv();
        
        // 设置Lua脚本加载路径
        luaEnv.AddLoader(CustomLoader);
        
        // 执行Lua脚本
        luaEnv.DoString("require 'main'");
    }
    
    // 自定义加载器（从热更目录加载）
    private byte[] CustomLoader(ref string filepath)
    {
        string hotfixPath = $"{Application.persistentDataPath}/lua/{filepath}.lua";
        if (File.Exists(hotfixPath))
        {
            return File.ReadAllBytes(hotfixPath);
        }
        
        // 回退到Resources
        TextAsset asset = Resources.Load<TextAsset>($"lua/{filepath}");
        return asset?.bytes;
    }
    
    void Update()
    {
        luaEnv?.Tick();  // 处理Lua的GC等
    }
    
    void OnDestroy()
    {
        luaEnv?.Dispose();
    }
}
```

```lua
-- Lua端：main.lua
local GameManager = require("GameManager")

function Start()
    print("Game Started from Lua!")
    GameManager.Init()
end

function Update(deltaTime)
    GameManager.Update(deltaTime)
end

Start()
```

### C#与Lua交互

```csharp
// C#调用Lua
public class CSharpCallLua : MonoBehaviour
{
    private LuaEnv luaEnv;
    private Action luaStart;
    private Action<float> luaUpdate;
    
    void Start()
    {
        luaEnv = new LuaEnv();
        luaEnv.DoString(@"
            function Start()
                print('Lua Start')
            end
            
            function Update(dt)
                -- 游戏逻辑
            end
        ");
        
        // 获取Lua函数
        luaStart = luaEnv.Global.Get<Action>("Start");
        luaUpdate = luaEnv.Global.Get<Action<float>>("Update");
        
        luaStart?.Invoke();
    }
    
    void Update()
    {
        luaUpdate?.Invoke(Time.deltaTime);
    }
}
```

```csharp
// Lua调用C#
// 需要在C#类上添加[LuaCallCSharp]特性

[LuaCallCSharp]
public class Player
{
    public string Name { get; set; }
    public int Level { get; set; }
    
    public void TakeDamage(int amount)
    {
        Debug.Log($"Player takes {amount} damage");
    }
}
```

```lua
-- Lua中调用C#
local CS = CS  -- C#命名空间

-- 创建C#对象
local player = CS.Player()
player.Name = "Hero"
player.Level = 10

-- 调用C#方法
player:TakeDamage(50)

-- 调用Unity API
local go = CS.UnityEngine.GameObject("NewObject")
local transform = go.transform
transform.position = CS.UnityEngine.Vector3(1, 2, 3)
```

---

## 10.4 ILRuntime

### 基本原理

```
ILRuntime原理：

1. 将C#编译为DLL
   ┌─────────────────────────────────────┐
   │ C#源码 → 编译 → DLL (IL字节码)      │
   └─────────────────────────────────────┘

2. ILRuntime解释执行IL
   ┌─────────────────────────────────────┐
   │ Unity主工程                         │
   │ ┌─────────────────────────────────┐ │
   │ │ ILRuntime解释器                 │ │
   │ │ ├─ 加载热更DLL                  │ │
   │ │ ├─ 解析IL指令                   │ │
   │ │ └─ 解释执行                     │ │
   │ └─────────────────────────────────┘ │
   └─────────────────────────────────────┘
```

### 使用示例

```csharp
// 主工程：加载热更DLL
using ILRuntime.Runtime.Enviorment;

public class ILRuntimeManager : MonoBehaviour
{
    private AppDomain appDomain;
    
    async void Start()
    {
        appDomain = new AppDomain();
        
        // 加载热更DLL
        byte[] dllBytes = await LoadDLL("HotFix.dll");
        byte[] pdbBytes = await LoadDLL("HotFix.pdb");
        
        using (MemoryStream dllStream = new MemoryStream(dllBytes))
        using (MemoryStream pdbStream = new MemoryStream(pdbBytes))
        {
            appDomain.LoadAssembly(dllStream, pdbStream, 
                new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());
        }
        
        // 注册委托适配器
        appDomain.DelegateManager.RegisterMethodDelegate<int>();
        appDomain.DelegateManager.RegisterFunctionDelegate<int, string>();
        
        // 调用热更代码
        appDomain.Invoke("HotFix.GameEntry", "Start", null, null);
    }
    
    void Update()
    {
        appDomain?.Invoke("HotFix.GameEntry", "Update", null, Time.deltaTime);
    }
}
```

```csharp
// 热更工程：HotFix.dll
namespace HotFix
{
    public class GameEntry
    {
        public static void Start()
        {
            Debug.Log("HotFix Started!");
        }
        
        public static void Update(float deltaTime)
        {
            // 游戏逻辑
        }
    }
}
```

---

## 10.5 HybridCLR

### 基本原理

```
HybridCLR原理：

传统IL2CPP：
┌─────────────────────────────────────┐
│ C#源码 → IL → IL2CPP → C++ → 机器码 │
│ （编译时完成，无法热更）             │
└─────────────────────────────────────┘

HybridCLR：
┌─────────────────────────────────────┐
│ 主工程：                            │
│ C#源码 → IL → IL2CPP → C++ → 机器码 │
│                                     │
│ 热更工程：                          │
│ C#源码 → IL → DLL                   │
│         ↓                           │
│ HybridCLR解释器（运行时加载执行）   │
└─────────────────────────────────────┘

特点：
• 扩展IL2CPP，支持动态加载DLL
• AOT + Interpreter混合执行
• 接近原生性能
```

### 使用示例

```csharp
// 加载热更程序集
public class HybridCLRLoader : MonoBehaviour
{
    async void Start()
    {
        // 加载热更DLL
        byte[] dllBytes = await LoadFromServer("HotUpdate.dll");
        
        // 加载程序集
        Assembly hotUpdateAssembly = Assembly.Load(dllBytes);
        
        // 获取入口类型
        Type entryType = hotUpdateAssembly.GetType("HotUpdate.GameEntry");
        
        // 调用入口方法
        MethodInfo startMethod = entryType.GetMethod("Start");
        startMethod.Invoke(null, null);
    }
}
```

```csharp
// 热更工程
namespace HotUpdate
{
    public class GameEntry
    {
        public static void Start()
        {
            // 可以使用完整的C#特性
            var list = new List<int> { 1, 2, 3 };
            var result = list.Where(x => x > 1).ToList();
            
            Debug.Log("HotUpdate Started!");
        }
    }
}
```

---

## 10.6 资源热更新

### 资源更新流程

```
资源热更新流程：

1. 版本检查
   ┌─────────────────────────────────────┐
   │ 客户端                服务器        │
   │    │                    │           │
   │    │ ─── 请求版本号 ──→ │           │
   │    │ ←── 返回最新版本 ─ │           │
   │    │                    │           │
   │    │ 比较本地版本       │           │
   └─────────────────────────────────────┘

2. 下载更新列表
   ┌─────────────────────────────────────┐
   │ 获取需要更新的文件列表              │
   │ ├─ 新增文件                         │
   │ ├─ 修改文件（MD5不同）              │
   │ └─ 删除文件                         │
   └─────────────────────────────────────┘

3. 下载资源
   ┌─────────────────────────────────────┐
   │ 下载AssetBundle                     │
   │ ├─ 断点续传                         │
   │ ├─ 校验MD5                          │
   │ └─ 解压（如果压缩）                 │
   └─────────────────────────────────────┘

4. 应用更新
   ┌─────────────────────────────────────┐
   │ 替换本地资源                        │
   │ 更新本地版本号                      │
   │ 重新加载资源                        │
   └─────────────────────────────────────┘
```

### 版本管理

```csharp
[Serializable]
public class VersionInfo
{
    public string version;
    public List<FileInfo> files;
}

[Serializable]
public class FileInfo
{
    public string name;
    public string md5;
    public long size;
}

public class UpdateManager
{
    public async Task<List<FileInfo>> CheckUpdate()
    {
        // 获取服务器版本信息
        string serverJson = await DownloadText(serverVersionUrl);
        VersionInfo serverVersion = JsonUtility.FromJson<VersionInfo>(serverJson);
        
        // 获取本地版本信息
        string localJson = File.ReadAllText(localVersionPath);
        VersionInfo localVersion = JsonUtility.FromJson<VersionInfo>(localJson);
        
        // 比较差异
        List<FileInfo> needUpdate = new List<FileInfo>();
        foreach (var serverFile in serverVersion.files)
        {
            var localFile = localVersion.files.Find(f => f.name == serverFile.name);
            if (localFile == null || localFile.md5 != serverFile.md5)
            {
                needUpdate.Add(serverFile);
            }
        }
        
        return needUpdate;
    }
    
    public async Task DownloadFiles(List<FileInfo> files, Action<float> onProgress)
    {
        long totalSize = files.Sum(f => f.size);
        long downloadedSize = 0;
        
        foreach (var file in files)
        {
            await DownloadFile(file.name, (progress) =>
            {
                float totalProgress = (downloadedSize + file.size * progress) / totalSize;
                onProgress?.Invoke(totalProgress);
            });
            downloadedSize += file.size;
        }
    }
}
```

---

## 面试要点总结

### 问题57：什么是热更新？为什么需要热更新？

**答案要点：**

1. **定义**：不重新安装App的情况下更新游戏内容

2. **需要原因**：
   - 快速修复Bug
   - 频繁更新内容
   - 减少首包大小
   - 绕过商店审核周期

3. **限制**：
   - iOS禁止下载可执行代码
   - 允许解释执行的脚本（Lua）

### 问题58：热更新的实现方案有哪些？

**答案要点：**

| 方案 | 特点 |
|------|------|
| Lua | 成熟稳定，iOS支持，需学习Lua |
| ILRuntime | 纯C#，性能较低 |
| HybridCLR | 原生性能，完整C#支持 |
| Puerts | TypeScript，前端友好 |

### 问题59：Lua热更新的原理是什么？

**答案要点：**

1. **Lua是解释型语言**：源码由虚拟机解释执行

2. **嵌入Unity**：Lua虚拟机作为插件嵌入

3. **热更流程**：
   - 下载新的Lua脚本
   - 替换本地脚本
   - 重新加载执行

4. **C#交互**：
   - C#调用Lua：获取Lua函数，Invoke调用
   - Lua调用C#：通过CS命名空间访问

---

[返回目录](./00_目录.md) | [上一章：资源管理](./09_资源管理.md) | [下一章：Lua](./11_Lua.md)