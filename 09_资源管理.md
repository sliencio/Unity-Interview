# 九、资源管理

> 本章涵盖问题：
> - Resources和AssetBundle的区别是什么？
> - AssetBundle的加载方式有哪些？
> - AssetBundle的依赖如何管理？
> - 什么是资源冗余？如何避免？
> - Addressables是什么？有什么优势？
> - 资源的生命周期是怎样的？
> - 如何检测资源泄漏？
> - 纹理压缩格式有哪些？如何选择？
> - 图集（Atlas）的作用是什么？
> - 资源异步加载如何实现？
> - Instantiate和资源加载的关系是什么？
> - 如何设计资源管理系统？

---

## 9.1 Resources vs AssetBundle

### Resources

```csharp
// Resources文件夹下的资源
// 路径：Assets/Resources/Prefabs/Player.prefab

// 同步加载
GameObject prefab = Resources.Load<GameObject>("Prefabs/Player");

// 异步加载
ResourceRequest request = Resources.LoadAsync<GameObject>("Prefabs/Player");
yield return request;
GameObject prefab = request.asset as GameObject;

// 卸载
Resources.UnloadAsset(asset);      // 卸载单个资源
Resources.UnloadUnusedAssets();    // 卸载未使用的资源
```

### AssetBundle

```csharp
// AssetBundle是资源打包文件

// 从文件加载
AssetBundle bundle = AssetBundle.LoadFromFile(path);

// 从内存加载
AssetBundle bundle = AssetBundle.LoadFromMemory(bytes);

// 从网络加载
UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(url);
yield return request.SendWebRequest();
AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);

// 加载资源
GameObject prefab = bundle.LoadAsset<GameObject>("Player");

// 卸载
bundle.Unload(false);  // 只卸载AB，不卸载已加载的资源
bundle.Unload(true);   // 卸载AB和所有已加载的资源
```

### 对比

| 特性 | Resources | AssetBundle |
|------|-----------|-------------|
| 打包位置 | 包含在安装包中 | 可以分离 |
| 热更新 | 不支持 | 支持 |
| 加载方式 | 路径字符串 | 需要先加载AB |
| 构建时间 | 影响构建 | 独立构建 |
| 内存管理 | 自动 | 手动 |
| 适用场景 | 小型项目、必需资源 | 大型项目、热更新 |

---

## 9.2 AssetBundle加载方式

### 四种加载方式

```csharp
// 1. LoadFromFile - 最快，推荐用于本地文件
AssetBundle bundle = AssetBundle.LoadFromFile(path);
// 异步版本
AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(path);

// 2. LoadFromMemory - 从内存加载，需要先读取到内存
byte[] data = File.ReadAllBytes(path);
AssetBundle bundle = AssetBundle.LoadFromMemory(data);
// 异步版本
AssetBundleCreateRequest request = AssetBundle.LoadFromMemoryAsync(data);

// 3. LoadFromStream - 从流加载，支持加密
FileStream stream = new FileStream(path, FileMode.Open);
AssetBundle bundle = AssetBundle.LoadFromStream(stream);

// 4. UnityWebRequest - 网络加载，支持缓存
UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(url, hash);
yield return request.SendWebRequest();
AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
```

### 性能对比

| 方式 | 速度 | 内存 | 适用场景 |
|------|------|------|----------|
| LoadFromFile | 最快 | 低 | 本地未压缩/LZ4 |
| LoadFromMemory | 慢 | 高（双倍） | 加密资源 |
| LoadFromStream | 中等 | 低 | 加密资源 |
| UnityWebRequest | 取决于网络 | 低 | 网络下载 |

---

## 9.3 AssetBundle依赖管理

### 依赖关系

```
假设资源依赖关系：
Character.prefab
├─ 依赖 Character.mat
│   └─ 依赖 Character.png
└─ 依赖 Character.anim

打包策略：
Bundle_Character: Character.prefab
Bundle_Material: Character.mat
Bundle_Texture: Character.png
Bundle_Animation: Character.anim

加载Character.prefab前，必须先加载所有依赖的Bundle
```

### 依赖加载

```csharp
public class AssetBundleManager
{
    private AssetBundleManifest manifest;
    private Dictionary<string, AssetBundle> loadedBundles = new Dictionary<string, AssetBundle>();
    
    // 初始化，加载Manifest
    public void Initialize(string manifestPath)
    {
        AssetBundle manifestBundle = AssetBundle.LoadFromFile(manifestPath);
        manifest = manifestBundle.LoadAsset<AssetBundleManifest>("AssetBundleManifest");
        manifestBundle.Unload(false);
    }
    
    // 加载Bundle及其依赖
    public AssetBundle LoadBundleWithDependencies(string bundleName)
    {
        // 获取所有依赖
        string[] dependencies = manifest.GetAllDependencies(bundleName);
        
        // 先加载依赖
        foreach (string dep in dependencies)
        {
            LoadBundle(dep);
        }
        
        // 再加载目标Bundle
        return LoadBundle(bundleName);
    }
    
    private AssetBundle LoadBundle(string bundleName)
    {
        if (loadedBundles.TryGetValue(bundleName, out AssetBundle bundle))
        {
            return bundle;  // 已加载，直接返回
        }
        
        bundle = AssetBundle.LoadFromFile(GetBundlePath(bundleName));
        loadedBundles[bundleName] = bundle;
        return bundle;
    }
    
    // 卸载Bundle
    public void UnloadBundle(string bundleName, bool unloadAllLoadedObjects)
    {
        if (loadedBundles.TryGetValue(bundleName, out AssetBundle bundle))
        {
            bundle.Unload(unloadAllLoadedObjects);
            loadedBundles.Remove(bundleName);
        }
    }
}
```

---

## 9.4 资源冗余

### 什么是资源冗余

```
场景：两个Prefab都引用同一个材质

不好的打包策略：
Bundle_A: PrefabA + MaterialX（复制）
Bundle_B: PrefabB + MaterialX（复制）
→ MaterialX被打包了两次，造成冗余

好的打包策略：
Bundle_A: PrefabA
Bundle_B: PrefabB
Bundle_Shared: MaterialX
→ MaterialX只打包一次，A和B都依赖Shared
```

### 检测冗余

```csharp
// 使用Unity的AssetBundle Browser工具
// 或者自定义脚本检测

public static void CheckRedundancy()
{
    var bundles = AssetDatabase.GetAllAssetBundleNames();
    var assetToBundles = new Dictionary<string, List<string>>();
    
    foreach (var bundle in bundles)
    {
        var assets = AssetDatabase.GetAssetPathsFromAssetBundle(bundle);
        foreach (var asset in assets)
        {
            // 获取依赖
            var deps = AssetDatabase.GetDependencies(asset, true);
            foreach (var dep in deps)
            {
                if (!assetToBundles.ContainsKey(dep))
                    assetToBundles[dep] = new List<string>();
                    
                if (!assetToBundles[dep].Contains(bundle))
                    assetToBundles[dep].Add(bundle);
            }
        }
    }
    
    // 找出被多个Bundle包含的资源
    foreach (var kvp in assetToBundles)
    {
        if (kvp.Value.Count > 1)
        {
            Debug.LogWarning($"冗余资源: {kvp.Key} 在 {string.Join(", ", kvp.Value)}");
        }
    }
}
```

### 避免冗余的策略

```
1. 公共资源单独打包
   └─ 被多个Bundle引用的资源打成独立Bundle

2. 按目录打包
   └─ 相关资源放在同一目录，整体打包

3. 按标签打包
   └─ 给资源打标签，相同标签打成一个Bundle

4. 使用Addressables
   └─ 自动分析依赖，避免冗余
```

---

## 9.5 Addressables

### 什么是Addressables

```
Addressables是Unity的新一代资源管理系统

优势：
• 统一的资源加载API
• 自动依赖管理
• 自动内存管理（引用计数）
• 支持本地和远程资源
• 可视化的资源分组
• 内置分析工具
```

### 基本使用

```csharp
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

// 通过地址加载
AsyncOperationHandle<GameObject> handle = Addressables.LoadAssetAsync<GameObject>("Player");
handle.Completed += (op) =>
{
    if (op.Status == AsyncOperationStatus.Succeeded)
    {
        GameObject prefab = op.Result;
        Instantiate(prefab);
    }
};

// 或者使用await
GameObject prefab = await Addressables.LoadAssetAsync<GameObject>("Player").Task;

// 实例化
AsyncOperationHandle<GameObject> handle = Addressables.InstantiateAsync("Player");

// 释放
Addressables.Release(handle);
Addressables.ReleaseInstance(gameObject);
```

### 引用计数

```csharp
// Addressables使用引用计数管理资源

// 加载资源，引用计数+1
var handle1 = Addressables.LoadAssetAsync<GameObject>("Player");
// 引用计数: 1

// 再次加载同一资源，引用计数+1
var handle2 = Addressables.LoadAssetAsync<GameObject>("Player");
// 引用计数: 2

// 释放一次，引用计数-1
Addressables.Release(handle1);
// 引用计数: 1

// 再释放，引用计数归0，资源被卸载
Addressables.Release(handle2);
// 引用计数: 0，资源卸载
```

---

## 9.6 资源生命周期

### Unity资源加载流程

```
资源加载流程：

1. 加载AssetBundle到内存
   ┌─────────────────────────────────────┐
   │ AssetBundle（压缩数据）             │
   └─────────────────────────────────────┘
   
2. 从AB加载Asset
   ┌─────────────────────────────────────┐
   │ Asset（Prefab、Texture等）          │
   │ 存在于Asset内存中                   │
   └─────────────────────────────────────┘
   
3. 实例化
   ┌─────────────────────────────────────┐
   │ Instance（场景中的GameObject）      │
   │ 引用Asset中的数据                   │
   └─────────────────────────────────────┘
```

### 内存占用

```
内存分布：

┌─────────────────────────────────────────────────────┐
│                    Unity内存                         │
├─────────────────────────────────────────────────────┤
│                                                     │
│  AssetBundle内存                                    │
│  ┌─────────────────────────────────────────────┐   │
│  │ AB文件数据（如果未卸载）                     │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  Asset内存                                          │
│  ┌─────────────────────────────────────────────┐   │
│  │ Texture、Mesh、Material等资源数据           │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  场景内存                                           │
│  ┌─────────────────────────────────────────────┐   │
│  │ GameObject、Component实例                    │   │
│  │ （引用Asset内存中的数据）                    │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### Unload策略

```csharp
// AssetBundle.Unload(false)
// 只卸载AB文件数据，已加载的Asset保留
bundle.Unload(false);
// 问题：Asset无法被卸载，可能造成泄漏

// AssetBundle.Unload(true)
// 卸载AB和所有已加载的Asset
bundle.Unload(true);
// 问题：如果有Instance引用Asset，会出现丢失（粉红色）

// 推荐流程
// 1. 确保所有Instance已销毁
// 2. 调用Unload(true)
// 3. 或者使用引用计数管理
```

---

## 9.7 资源泄漏检测

### 常见泄漏原因

```
1. AssetBundle未卸载
   └─ 加载后忘记Unload

2. 资源引用未释放
   └─ 静态变量持有资源引用
   └─ 事件未取消订阅

3. Texture/RenderTexture未释放
   └─ 动态创建的纹理未Destroy

4. 材质实例未释放
   └─ renderer.material创建了实例
```

### 检测方法

```csharp
// 1. 使用Profiler
// Memory Profiler可以查看所有资源

// 2. 代码检测
public class ResourceTracker
{
    private static Dictionary<string, int> loadedAssets = new Dictionary<string, int>();
    
    public static void TrackLoad(string assetName)
    {
        if (!loadedAssets.ContainsKey(assetName))
            loadedAssets[assetName] = 0;
        loadedAssets[assetName]++;
        Debug.Log($"Load: {assetName}, Count: {loadedAssets[assetName]}");
    }
    
    public static void TrackUnload(string assetName)
    {
        if (loadedAssets.ContainsKey(assetName))
        {
            loadedAssets[assetName]--;
            Debug.Log($"Unload: {assetName}, Count: {loadedAssets[assetName]}");
            
            if (loadedAssets[assetName] <= 0)
                loadedAssets.Remove(assetName);
        }
    }
    
    public static void PrintLeaks()
    {
        foreach (var kvp in loadedAssets)
        {
            if (kvp.Value > 0)
                Debug.LogWarning($"Leak: {kvp.Key}, Count: {kvp.Value}");
        }
    }
}

// 3. 使用Unity的Memory Profiler包
// 可以拍摄内存快照，对比分析
```

---

## 9.8 纹理压缩格式

### 各平台推荐格式

| 平台 | 推荐格式 | 说明 |
|------|----------|------|
| Windows/Mac | DXT1/DXT5 (BC1/BC3) | DXT1无Alpha，DXT5有Alpha |
| iOS | PVRTC/ASTC | ASTC质量更好，iOS 8+ |
| Android | ETC2/ASTC | ETC2是OpenGL ES 3.0标准 |
| WebGL | DXT/ETC | 取决于浏览器 |

### 压缩比和质量

```
原始RGBA32: 4 bytes/pixel

压缩格式对比（1024x1024纹理）：
┌─────────────┬──────────────┬──────────┬──────────┐
│ 格式        │ 大小         │ 压缩比   │ 质量     │
├─────────────┼──────────────┼──────────┼──────────┤
│ RGBA32      │ 4 MB         │ 1:1      │ 最高     │
│ RGB24       │ 3 MB         │ 1.33:1   │ 高       │
│ DXT1        │ 0.5 MB       │ 8:1      │ 中       │
│ DXT5        │ 1 MB         │ 4:1      │ 中       │
│ ETC2 RGB    │ 0.5 MB       │ 8:1      │ 中       │
│ ETC2 RGBA   │ 1 MB         │ 4:1      │ 中       │
│ ASTC 4x4    │ 1 MB         │ 4:1      │ 高       │
│ ASTC 6x6    │ 0.44 MB      │ 9:1      │ 中       │
│ ASTC 8x8    │ 0.25 MB      │ 16:1     │ 中低     │
└─────────────┴──────────────┴──────────┴──────────┘
```

### 设置纹理压缩

```csharp
// 通过Import Settings设置
// 或者代码设置
TextureImporter importer = AssetImporter.GetAtPath(path) as TextureImporter;

// 设置平台特定格式
TextureImporterPlatformSettings settings = new TextureImporterPlatformSettings();
settings.name = "Android";
settings.overridden = true;
settings.format = TextureImporterFormat.ASTC_6x6;
settings.maxTextureSize = 1024;
importer.SetPlatformTextureSettings(settings);

importer.SaveAndReimport();
```

---

## 9.9 图集（Sprite Atlas）

### 图集的作用

```
不使用图集：
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│ A   │ │ B   │ │ C   │ │ D   │  4个纹理 = 4个Draw Call
└─────┘ └─────┘ └─────┘ └─────┘

使用图集：
┌─────────────────────┐
│ ┌───┐ ┌───┐        │
│ │ A │ │ B │        │  1个纹理 = 1个Draw Call
│ └───┘ └───┘        │
│ ┌───┐ ┌───┐        │
│ │ C │ │ D │        │
│ └───┘ └───┘        │
└─────────────────────┘
```

### 创建图集

```csharp
// 1. 创建Sprite Atlas资源
// Assets -> Create -> 2D -> Sprite Atlas

// 2. 添加Sprite到图集
// 拖拽文件夹或单个Sprite到Atlas的Objects for Packing

// 3. 代码加载
SpriteAtlas atlas = Resources.Load<SpriteAtlas>("MyAtlas");
Sprite sprite = atlas.GetSprite("icon_sword");
```

### 图集设置

```csharp
// 重要设置
// Include in Build: 是否包含在构建中
// Allow Rotation: 允许旋转以节省空间
// Tight Packing: 紧密打包
// Padding: Sprite之间的间距（避免出血）

// 变体图集（用于不同分辨率）
// 可以创建低分辨率变体用于低端设备
```

---

## 9.10 异步加载

### 协程方式

```csharp
IEnumerator LoadAssetAsync()
{
    // Resources异步加载
    ResourceRequest request = Resources.LoadAsync<GameObject>("Prefabs/Player");
    yield return request;
    GameObject prefab = request.asset as GameObject;
    
    // AssetBundle异步加载
    AssetBundleCreateRequest bundleRequest = AssetBundle.LoadFromFileAsync(path);
    yield return bundleRequest;
    AssetBundle bundle = bundleRequest.assetBundle;
    
    AssetBundleRequest assetRequest = bundle.LoadAssetAsync<GameObject>("Player");
    yield return assetRequest;
    GameObject prefab2 = assetRequest.asset as GameObject;
}
```

### async/await方式

```csharp
async Task LoadAssetAsync()
{
    // Addressables
    GameObject prefab = await Addressables.LoadAssetAsync<GameObject>("Player").Task;
    
    // 自定义封装
    GameObject prefab2 = await LoadFromBundleAsync("bundle", "Player");
}

async Task<T> LoadFromBundleAsync<T>(string bundleName, string assetName) where T : Object
{
    var bundleRequest = AssetBundle.LoadFromFileAsync(GetPath(bundleName));
    while (!bundleRequest.isDone)
        await Task.Yield();
    
    var assetRequest = bundleRequest.assetBundle.LoadAssetAsync<T>(assetName);
    while (!assetRequest.isDone)
        await Task.Yield();
    
    return assetRequest.asset as T;
}
```

### 加载进度

```csharp
IEnumerator LoadWithProgress()
{
    AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(path);
    
    while (!request.isDone)
    {
        float progress = request.progress;
        UpdateProgressBar(progress);
        yield return null;
    }
    
    // 加载完成
}
```

---

## 9.11 Instantiate与资源加载

### Instantiate的工作原理

```csharp
// Instantiate创建的是实例，不是新资源
GameObject prefab = Resources.Load<GameObject>("Player");
GameObject instance = Instantiate(prefab);

// instance引用prefab中的资源（Mesh、Texture、Material等）
// 不会复制这些资源，只是引用
```

```
内存关系：

Asset内存：
┌─────────────────────────────────────┐
│ Prefab                              │
│ ├─ Mesh数据                         │
│ ├─ Texture数据                      │
│ └─ Material数据                     │
└─────────────────────────────────────┘
         ↑           ↑           ↑
         │           │           │
         │           │           │
┌────────┴───┐ ┌─────┴────┐ ┌────┴─────┐
│ Instance1  │ │ Instance2│ │ Instance3│
│ (引用)     │ │ (引用)   │ │ (引用)   │
└────────────┘ └──────────┘ └──────────┘

场景内存（只有Transform、Component等实例数据）
```

### 材质实例化

```csharp
// 注意：访问renderer.material会创建材质实例
Renderer renderer = GetComponent<Renderer>();

// 这会创建新的材质实例（需要手动销毁）
renderer.material.color = Color.red;

// 使用sharedMaterial不会创建实例
renderer.sharedMaterial.color = Color.red;  // 影响所有使用该材质的对象

// 正确做法：使用MaterialPropertyBlock
MaterialPropertyBlock block = new MaterialPropertyBlock();
block.SetColor("_Color", Color.red);
renderer.SetPropertyBlock(block);  // 不创建新材质
```

---

## 9.12 资源管理系统设计

### 基本架构

```csharp
public class ResourceManager : MonoBehaviour
{
    private static ResourceManager instance;
    public static ResourceManager Instance => instance;
    
    private Dictionary<string, AssetBundle> loadedBundles = new Dictionary<string, AssetBundle>();
    private Dictionary<string, Object> cachedAssets = new Dictionary<string, Object>();
    private Dictionary<string, int> referenceCount = new Dictionary<string, int>();
    
    void Awake()
    {
        instance = this;
        DontDestroyOnLoad(gameObject);
    }
    
    // 加载资源
    public T Load<T>(string path) where T : Object
    {
        if (cachedAssets.TryGetValue(path, out Object asset))
        {
            AddReference(path);
            return asset as T;
        }
        
        // 加载逻辑...
        T loadedAsset = LoadFromBundle<T>(path);
        cachedAssets[path] = loadedAsset;
        AddReference(path);
        return loadedAsset;
    }
    
    // 异步加载
    public void LoadAsync<T>(string path, Action<T> callback) where T : Object
    {
        StartCoroutine(LoadAsyncCoroutine(path, callback));
    }
    
    private IEnumerator LoadAsyncCoroutine<T>(string path, Action<T> callback) where T : Object
    {
        // 异步加载逻辑...
        yield return null;
        callback?.Invoke(null);
    }
    
    // 引用计数
    private void AddReference(string path)
    {
        if (!referenceCount.ContainsKey(path))
            referenceCount[path] = 0;
        referenceCount[path]++;
    }
    
    // 释放资源
    public void Release(string path)
    {
        if (referenceCount.ContainsKey(path))
        {
            referenceCount[path]--;
            if (referenceCount[path] <= 0)
            {
                // 真正卸载资源
                UnloadAsset(path);
            }
        }
    }
    
    private void UnloadAsset(string path)
    {
        if (cachedAssets.TryGetValue(path, out Object asset))
        {
            Resources.UnloadAsset(asset);
            cachedAssets.Remove(path);
            referenceCount.Remove(path);
        }
    }
}
```

---

## 面试要点总结

### 问题45：Resources和AssetBundle的区别是什么？

**答案要点：**
- **Resources**：包含在安装包中，不支持热更新，自动管理
- **AssetBundle**：可分离，支持热更新，需要手动管理

### 问题46：AssetBundle的加载方式有哪些？

**答案要点：**
1. LoadFromFile：最快，用于本地文件
2. LoadFromMemory：从内存加载，内存占用高
3. LoadFromStream：支持加密
4. UnityWebRequest：网络下载

### 问题47：AssetBundle的依赖如何管理？

**答案要点：**
1. 通过Manifest获取依赖关系
2. 加载资源前先加载所有依赖的Bundle
3. 使用引用计数管理卸载

### 问题48：什么是资源冗余？如何避免？

**答案要点：**
- **冗余**：同一资源被打包到多个Bundle中
- **避免**：公共资源单独打包，使用Addressables自动分析

### 问题49：Addressables是什么？有什么优势？

**答案要点：**
- 统一的资源加载API
- 自动依赖管理
- 引用计数自动内存管理
- 支持本地和远程资源

### 问题50：资源的生命周期是怎样的？

**答案要点：**
1. 加载AB到内存
2. 从AB加载Asset
3. Instantiate创建实例
4. 销毁实例
5. 卸载Asset
6. 卸载AB

### 问题51：如何检测资源泄漏？

**答案要点：**
- 使用Memory Profiler
- 自定义引用计数追踪
- 检查静态引用和事件订阅

### 问题52：纹理压缩格式有哪些？如何选择？

**答案要点：**
- Windows：DXT1/DXT5
- iOS：PVRTC/ASTC
- Android：ETC2/ASTC
- 根据质量和大小需求选择

### 问题53：图集（Atlas）的作用是什么？

**答案要点：**
- 减少Draw Call（合批）
- 减少纹理切换
- 优化内存使用

### 问题54：资源异步加载如何实现？

**答案要点：**
- 使用协程 + yield return
- 使用async/await
- 监听progress获取进度

### 问题55：Instantiate和资源加载的关系是什么？

**答案要点：**
- Instantiate创建实例，不复制资源
- 实例引用原始Asset中的数据
- 注意material会创建实例

### 问题56：如何设计资源管理系统？

**答案要点：**
1. 统一的加载/卸载接口
2. 引用计数管理
3. 缓存机制
4. 异步加载支持
5. 依赖管理

---

[返回目录](./00_目录.md) | [上一章：UGUI](./08_UGUI.md) | [下一章：热更新](./10_热更新.md)