# 一、GC 垃圾回收

> 本章涵盖问题：
> 1. GC是什么？触发时机是什么？
> 2. GC导致卡顿的原因是什么？
> 3. 如何减少GC？
> 4. 什么情况下会产生GC？（高频GC产生点）
> 5. C#和Lua的GC方式有什么区别？
> 6. 托管堆是什么？

---

## 1.1 什么是Boehm GC？为什么Unity选择它？

### Boehm GC的历史与设计

Boehm GC（也称为Boehm-Demers-Weiser GC）是由Hans Boehm在1988年开发的一个保守式垃圾回收器，最初设计用于C/C++程序。

**Unity选择Boehm GC的原因：**

1. **跨平台兼容性**：Boehm GC支持几乎所有平台，这对Unity的多平台战略至关重要
2. **与Native代码兼容**：Unity引擎核心是C++，Boehm GC可以与Native代码无缝协作
3. **历史原因**：Mono运行时最初就使用Boehm GC，Unity基于Mono构建

### Boehm GC的核心特性

```
┌─────────────────────────────────────────────────────────────────┐
│                    Boehm GC 特性分析                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 保守式（Conservative）                                       │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ 不依赖类型信息，将所有看起来像指针的值都当作指针处理    │     │
│     │ 优点：实现简单，与C/C++兼容                           │     │
│     │ 缺点：可能误判，导致内存无法回收                       │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                 │
│  2. 非分代（Non-generational）                                   │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ 每次GC都扫描整个堆，不区分新生代和老年代               │     │
│     │ 对比.NET GC：分为Gen0、Gen1、Gen2三代                  │     │
│     │ 影响：大堆时GC时间长                                  │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                 │
│  3. 非压缩式（Non-compacting）                                   │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ 回收后不整理内存，可能产生碎片                         │     │
│     │ 对比.NET GC：会压缩内存，消除碎片                      │     │
│     │ 影响：长时间运行后内存碎片化                          │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                 │
│  4. 标记-清除（Mark-Sweep）                                      │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ 阶段1：从GC Root开始，标记所有可达对象                 │     │
│     │ 阶段2：清除所有未标记的对象                           │     │
│     │ 整个过程需要Stop The World                            │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1.2 GC触发时机

```
┌─────────────────────────────────────────────────────────────────┐
│                    GC 触发条件                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 分配请求时堆空间不足                                        │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ 当 new 对象时，托管堆剩余空间不足以分配              │    │
│     │ 触发GC尝试回收内存                                   │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. 堆大小超过阈值                                              │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ 托管堆增长到一定大小时自动触发                       │    │
│     │ 阈值会根据使用情况动态调整                           │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. 手动调用 GC.Collect()                                       │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ 不推荐频繁调用                                       │    │
│     │ 适合在场景切换等明确时机使用                         │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  4. 场景切换（Unity特有）                                       │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ Unity在场景切换时会触发GC                            │    │
│     │ 清理上一个场景的资源                                 │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1.3 GC导致卡顿的原因

### 标记-清除算法详解

```
                    GC执行过程图示
                    
Step 1: 初始状态（所有对象未标记）
┌─────────────────────────────────────────────────────────────┐
│  GC Roots                                                   │
│  ┌─────┐                                                    │
│  │ 栈  │──────┐                                             │
│  └─────┘      │                                             │
│  ┌─────┐      ▼                                             │
│  │静态 │──→ [A]──→[B]──→[C]                                 │
│  │变量 │      │                                             │
│  └─────┘      ▼                                             │
│             [D]──→[E]                                       │
│                                                             │
│  孤立对象（无引用）：[F] [G] [H]                              │
└─────────────────────────────────────────────────────────────┘

Step 2: 标记阶段（从GC Root遍历，标记可达对象）
┌─────────────────────────────────────────────────────────────┐
│  GC Roots                                                   │
│  ┌─────┐                                                    │
│  │ 栈  │──────┐                                             │
│  └─────┘      │                                             │
│  ┌─────┐      ▼                                             │
│  │静态 │──→ [A✓]──→[B✓]──→[C✓]                              │
│  │变量 │      │                                             │
│  └─────┘      ▼                                             │
│             [D✓]──→[E✓]                                     │
│                                                             │
│  未标记对象：[F✗] [G✗] [H✗]                                  │
└─────────────────────────────────────────────────────────────┘

Step 3: 清除阶段（回收未标记对象）
┌─────────────────────────────────────────────────────────────┐
│  GC Roots                                                   │
│  ┌─────┐                                                    │
│  │ 栈  │──────┐                                             │
│  └─────┘      │                                             │
│  ┌─────┐      ▼                                             │
│  │静态 │──→ [A]──→[B]──→[C]                                 │
│  │变量 │      │                                             │
│  └─────┘      ▼                                             │
│             [D]──→[E]                                       │
│                                                             │
│  空闲内存块：[   ] [   ] [   ]  ← F、G、H被回收              │
└─────────────────────────────────────────────────────────────┘
```

### 卡顿原因分析

```
┌─────────────────────────────────────────────────────────────────┐
│                    GC 卡顿原因                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Stop The World（暂停所有托管线程）                          │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 所有托管线程到达安全点（Safe Point）               │    │
│     │ • 线程状态保存                                       │    │
│     │ • 这是造成卡顿的主要原因                             │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. 非分代扫描                                                  │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 每次GC都扫描整个堆                                 │    │
│     │ • 堆越大，扫描时间越长                               │    │
│     │ • 时间复杂度：O(存活对象数量)                        │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. 60FPS的时间预算                                             │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 每帧只有16.67ms                                    │    │
│     │ • 一次GC可能耗时几毫秒到几十毫秒                     │    │
│     │ • 超过预算就会掉帧                                   │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  总耗时 = STW准备 + 标记时间 + 清除时间 + 恢复时间              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1.4 高频GC产生点

```
┌─────────────────────────────────────────────────────────────────┐
│                    常见GC产生场景                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 字符串操作                                                  │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ string s = "Hello" + " " + "World";  // 产生临时字符串│    │
│     │ string.Format("{0}", value);  // 产生GC              │    │
│     │ ToString() 调用                                      │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. 装箱操作                                                    │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ object obj = 42;  // int装箱为object                 │    │
│     │ list.Contains(enumValue);  // enum装箱               │    │
│     │ string.Format("{0}", intValue);  // 参数装箱         │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. 集合操作                                                    │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ new List<T>() 在循环中                               │    │
│     │ LINQ查询（产生迭代器）                               │    │
│     │ ToArray(), ToList() 等转换                           │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  4. 委托和闭包                                                  │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ () => { }  // Lambda表达式可能产生闭包类             │    │
│     │ 事件订阅 += handler                                  │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  5. Unity API                                                   │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ GetComponent<T>() 在某些情况下                       │    │
│     │ GameObject.name, .tag 属性访问                       │    │
│     │ Input.touches 数组                                   │    │
│     │ Physics.RaycastAll() 返回数组                        │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  6. 协程                                                        │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ new WaitForSeconds(1f)  // 每次new都产生GC           │    │
│     │ yield return new ...                                 │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1.5 如何减少GC

### 对象池原理

```
没有对象池：
┌─────────────────────────────────────────────────────────────────┐
│  时间 →                                                         │
│                                                                 │
│  帧1: new Bullet() → 堆分配                                     │
│  帧2: Bullet销毁 → 等待GC                                       │
│  帧3: new Bullet() → 堆分配                                     │
│  帧4: Bullet销毁 → 等待GC                                       │
│  ...                                                            │
│  帧N: GC触发 → 卡顿！                                           │
│                                                                 │
│  问题：频繁分配导致堆增长，最终触发GC                            │
└─────────────────────────────────────────────────────────────────┘

使用对象池：
┌─────────────────────────────────────────────────────────────────┐
│  初始化: 预创建10个Bullet对象                                    │
│                                                                 │
│  对象池: [B1] [B2] [B3] [B4] [B5] [B6] [B7] [B8] [B9] [B10]     │
│                                                                 │
│  帧1: 从池中取出B1 → 无堆分配                                   │
│  帧2: B1归还池中 → 无GC                                         │
│  帧3: 从池中取出B1 → 无堆分配（复用）                           │
│  帧4: B1归还池中 → 无GC                                         │
│  ...                                                            │
│                                                                 │
│  结果：零GC！                                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 对象池实现

```csharp
public class ObjectPool<T> where T : class, new()
{
    private readonly Stack<T> _pool;
    private readonly Action<T> _onGet;
    private readonly Action<T> _onReturn;
    
    public ObjectPool(int initialCapacity, Action<T> onGet = null, Action<T> onReturn = null)
    {
        _pool = new Stack<T>(initialCapacity);
        _onGet = onGet;
        _onReturn = onReturn;
        
        // 预热：预先创建对象
        for (int i = 0; i < initialCapacity; i++)
        {
            _pool.Push(new T());
        }
    }
    
    public T Get()
    {
        T obj = _pool.Count > 0 ? _pool.Pop() : new T();
        _onGet?.Invoke(obj);
        return obj;
    }
    
    public void Return(T obj)
    {
        _onReturn?.Invoke(obj);
        _pool.Push(obj);
    }
}

// 使用示例
var bulletPool = new ObjectPool<Bullet>(
    initialCapacity: 100,
    onGet: bullet => bullet.Reset(),
    onReturn: bullet => bullet.Deactivate()
);
```

### 其他优化方法

```
┌─────────────────────────────────────────────────────────────────┐
│                    GC优化速查表                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✗ 避免                        │ ✓ 推荐                        │
│  ─────────────────────────────┼─────────────────────────────   │
│  string + 拼接                │ StringBuilder                  │
│  foreach (接口类型)           │ for循环 / 具体类型             │
│  new WaitForSeconds()         │ 缓存WaitForSeconds             │
│  频繁new类对象                │ 对象池                         │
│  LINQ在Update中               │ 手动循环                       │
│  闭包捕获                     │ 传参或成员变量                 │
│  装箱（值类型→object）        │ 泛型                           │
│  GetComponent在Update中       │ Awake中缓存                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1.6 托管堆（Managed Heap）

### 什么是托管堆？

托管堆是CLR（Common Language Runtime）管理的一块连续内存区域，用于存储所有引用类型对象。

```
┌─────────────────────────────────────────────────────────────────┐
│                    进程内存布局                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  高地址                                                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    内核空间                              │   │
│  ├─────────────────────────────────────────────────────────┤   │
│  │                    栈（Stack）                           │   │
│  │                    ↓ 向下增长                            │   │
│  │                    ...                                   │   │
│  │                    ↑ 向上增长                            │   │
│  │                    堆（Heap）                            │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │              托管堆（Managed Heap）              │    │   │
│  │  │  ┌─────────────────────────────────────────┐   │    │   │
│  │  │  │  对象1  │  对象2  │  空闲  │  对象3  │...│   │    │   │
│  │  │  └─────────────────────────────────────────┘   │    │   │
│  │  │              由GC管理                          │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │              非托管堆（Native Heap）            │    │   │
│  │  │              Unity引擎对象、纹理、网格等        │    │   │
│  │  │              需要手动管理                       │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  ├─────────────────────────────────────────────────────────┤   │
│  │                    数据段（全局变量）                    │   │
│  ├─────────────────────────────────────────────────────────┤   │
│  │                    代码段（程序指令）                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│  低地址                                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Unity托管堆的特殊行为

```
Unity托管堆的"只增不减"特性：

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  时间线 ──────────────────────────────────────────────────→     │
│                                                                 │
│  堆大小                                                         │
│    ↑                                                            │
│    │                    ┌─────────────────────────────          │
│    │              ┌─────┘                                       │
│    │        ┌─────┘                                             │
│    │  ┌─────┘                                                   │
│    │──┘                                                         │
│    └─────────────���──────────────────────────────────────→ 时间  │
│                                                                 │
│  说明：                                                         │
│  - 每次分配不足时，堆会扩展                                      │
│  - GC后，内存不会归还给操作系统                                  │
│  - 堆大小只会增加，不会减少                                      │
│  - 这是为了避免频繁的系统调用                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1.7 C# GC vs Lua GC

```
┌─────────────────────────────────────────────────────────────────┐
│                    C# GC vs Lua GC 对比                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┬──────────────────┬──────────────────┐        │
│  │ 特性         │ C# (Boehm)       │ Lua              │        │
│  ├──────────────┼──────────────────┼──────────────────┤        │
│  │ 算法         │ 标记-清除        │ 增量标记-清除    │        │
│  │ 分代         │ 否               │ 否               │        │
│  │ 增量         │ 否               │ 是               │        │
│  │ 压缩         │ 否               │ 否               │        │
│  │ 停顿         │ 可能较长         │ 较短（增量）     │        │
│  │ 控制         │ 有限             │ 灵活             │        │
│  └──────────────┴──────────────────┴──────────────────┘        │
│                                                                 │
│  Lua GC的增量特性：                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • 不是一次性完成，分多步执行                            │   │
│  │ • 每步只处理一部分对象                                  │   │
│  │ • 减少单次GC造成的卡顿                                  │   │
│  │ • 可以通过collectgarbage("step", n)控制                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Lua GC控制：                                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ collectgarbage("collect")  -- 完整GC                    │   │
│  │ collectgarbage("step", n)  -- 执行n步                   │   │
│  │ collectgarbage("stop")     -- 停止GC                    │   │
│  │ collectgarbage("restart")  -- 重启GC                    │   │
│  │ collectgarbage("count")    -- 返回内存使用量(KB)        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 面试要点总结

### 问题1：GC是什么？触发时机是什么？
**答案要点：**
- GC是垃圾回收机制，自动管理托管堆内存
- Unity使用Boehm GC，是标记-清除算法
- 触发时机：堆空间不足、超过阈值、手动调用、场景切换

### 问题2：GC导致卡顿的原因是什么？
**答案要点：**
- Stop The World：暂停所有托管线程
- 非分代：每次扫描整个堆
- 60FPS只有16.67ms预算，GC可能耗时几十毫秒

### 问题3：如何减少GC？
**答案要点：**
- 使用对象池复用对象
- 避免字符串拼接，使用StringBuilder
- 缓存组件引用，避免频繁GetComponent
- 避免装箱，使用泛型
- 缓存WaitForSeconds等协程对象

### 问题4：什么情况下会产生GC？
**答案要点：**
- 字符串操作、装箱、集合操作
- 委托和闭包、Unity API返回数组
- 协程中new对象

### 问题5：C#和Lua的GC方式有什么区别？
**答案要点：**
- C# Boehm GC：非增量，可能长时间停顿
- Lua GC：增量式，分步执行，停顿较短
- Lua GC可以更灵活地控制

### 问题6：托管堆是什么？
**答案要点：**
- CLR管理的内存区域，存储引用类型对象
- Unity托管堆"只增不减"
- 与非托管堆（Native Heap）区分

---

[返回目录](./00_目录.md) | [下一章：渲染与优化](./02_渲染与优化.md)