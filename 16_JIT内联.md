# 十六、JIT与内联

> 本章涵盖问题：
> - 什么是JIT编译？
> - 什么是方法内联？有什么好处？
> - IL2CPP和Mono的区别是什么？
> - 如何影响JIT的内联决策？
> - AOT和JIT的区别是什么？

---

## 16.1 JIT编译

### 什么是JIT

```
JIT（Just-In-Time）即时编译：

传统编译（C/C++）：
┌─────────┐    ┌─────────┐    ┌─────────┐
│ 源代码  │ → │ 编译器  │ → │ 机器码  │
└─────────┘    └─────────┘    └─────────┘
                              （运行前完成）

JIT编译（C#/Java）：
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 源代码  │ → │ 编译器  │ → │ IL/字节码│ → │ 机器码  │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                              （运行时编译）
                                   ↑
                              JIT编译器
```

### C#编译流程

```
C#代码编译流程：

1. 编译时（开发机器）
   ┌─────────────────────────────────────┐
   │ C#源代码 (.cs)                      │
   │         ↓                           │
   │ C#编译器 (csc/Roslyn)               │
   │         ↓                           │
   │ IL代码 (.dll)                       │
   │ （中间语言，平台无关）               │
   └─────────────────────────────────────┘

2. 运行时（目标机器）
   ┌─────────────────────────────────────┐
   │ IL代码                              │
   │         ↓                           │
   │ JIT编译器                           │
   │         ↓                           │
   │ 机器码（平台相关）                   │
   │         ↓                           │
   │ CPU执行                             │
   └─────────────────────────────────────┘
```

### JIT的优缺点

| 优点 | 缺点 |
|------|------|
| 跨平台（IL平台无关） | 首次执行有编译延迟 |
| 运行时优化（根据实际情况） | 需要JIT编译器 |
| 代码体积小（IL比机器码小） | 内存占用（IL+机器码） |
| 支持反射和动态代码 | iOS不允许JIT |

---

## 16.2 方法内联

### 什么是内联

```
方法内联：将方法调用替换为方法体

未内联：
┌─────────────────────────────────────┐
│ void Update()                       │
│ {                                   │
│     int result = Add(a, b);  // 调用│
│ }                                   │
│                                     │
│ int Add(int x, int y)               │
│ {                                   │
│     return x + y;                   │
│ }                                   │
└─────────────────────────────────────┘

内联后：
┌─────────────────────────────────────┐
│ void Update()                       │
│ {                                   │
│     int result = a + b;  // 直接计算│
│ }                                   │
└─────────────────────────────────────┘
```

### 内联的好处

```
1. 消除调用开销
   ├─ 无需压栈/出栈
   ├─ 无需跳转
   └─ 无需返回

2. 启用更多优化
   ├─ 常量折叠
   ├─ 死代码消除
   └─ 循环优化

3. 提高缓存命中
   └─ 代码更紧凑
```

### 内联的代价

```
1. 代码膨胀
   └─ 多处调用 = 多份代码

2. 编译时间增加
   └─ 更多代码需要编译

3. 指令缓存压力
   └─ 代码过大可能降低缓存效率
```

---

## 16.3 JIT内联决策

### 影响内联的因素

```csharp
// 1. 方法大小
// 小方法更容易被内联（通常<32字节IL）

// 容易内联
int GetValue() => value;

// 不容易内联（方法体太大）
void ComplexMethod()
{
    // 大量代码...
}

// 2. 调用频率
// 热点方法更可能被内联

// 3. 虚方法
// 虚方法通常不内联（运行时才知道调用哪个）
virtual void VirtualMethod() { }  // 不内联

// 4. 递归
// 递归方法不内联
void Recursive(int n)
{
    if (n > 0) Recursive(n - 1);  // 不内联
}

// 5. 异常处理
// 包含try-catch的方法可能不内联
void MethodWithTry()
{
    try { } catch { }  // 可能不内联
}
```

### 强制内联（.NET）

```csharp
using System.Runtime.CompilerServices;

// 建议内联
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public int Add(int a, int b)
{
    return a + b;
}

// 禁止内联
[MethodImpl(MethodImplOptions.NoInlining)]
public void NoInlineMethod()
{
    // ...
}

// 注意：这只是建议，JIT可能忽略
```

### Unity中的内联

```csharp
// Unity/Mono的内联限制较多
// IL2CPP有更好的内联优化

// 1. 属性访问
// 简单属性通常会内联
public int Value { get; set; }

// 2. 小方法
// 简单的getter/setter会内联
public int GetValue() => _value;

// 3. 使用struct避免虚调用
// struct方法更容易内联（无虚表）
public struct Vector3
{
    public float Magnitude() => Mathf.Sqrt(x*x + y*y + z*z);
}
```

---

## 16.4 Mono vs IL2CPP

### 对比

```
Mono：
┌─────────────────────────────────────┐
│ C# → IL → JIT → 机器码              │
│                                     │
│ 特点：                              │
│ ├─ 运行时编译                       │
│ ├─ 支持反射和动态代码               │
│ ├─ 启动较快                         │
│ └─ 运行时性能一般                   │
└─────────────────────────────────────┘

IL2CPP：
┌─────────────────────────────────────┐
│ C# → IL → C++ → 机器码              │
│                                     │
│ 特点：                              │
│ ├─ 提前编译（AOT）                  │
│ ├─ 更好的性能优化                   │
│ ├─ 更小的运行时                     │
│ ├─ 支持iOS（无JIT）                 │
│ └─ 构建时间长                       │
└─────────────────────────────────────┘
```

### 详细对比

| 特性 | Mono | IL2CPP |
|------|------|--------|
| 编译方式 | JIT | AOT |
| 运行时性能 | 一般 | 更好 |
| 启动时间 | 快 | 稍慢 |
| 构建时间 | 快 | 慢 |
| 包体大小 | 较大 | 较小 |
| iOS支持 | 受限 | 完全支持 |
| 反射 | 完全支持 | 部分限制 |
| 代码剥离 | 有限 | 更激进 |

### IL2CPP的优化

```csharp
// IL2CPP可以进行更多优化：

// 1. 更好的内联
// IL2CPP使用C++编译器，内联更激进

// 2. 泛型特化
// 为每个泛型类型生成专门的代码
List<int> list;  // 生成专门的int版本

// 3. 虚调用优化
// 某些情况下可以去虚拟化

// 4. 死代码消除
// 更激进地移除未使用的代码
```

---

## 16.5 AOT vs JIT

### 对比

```
AOT（Ahead-Of-Time）提前编译：
┌─────────────────────────────────────┐
│ 编译时：源代码 → 机器码             │
│ 运行时：直接执行机器码              │
│                                     │
│ 优点：                              │
│ ├─ 启动快（无编译延迟）             │
│ ├─ 运行时内存小                     │
│ └─ 可预测的性能                     │
│                                     │
│ 缺点：                              │
│ ├─ 无法运行时优化                   │
│ ├─ 包体较大                         │
│ └─ 反射受限                         │
└─────────────────────────────────────┘

JIT（Just-In-Time）即时编译：
┌─────────────────────────────────────┐
│ 编译时：源代码 → IL                 │
│ 运行时：IL → 机器码                 │
│                                     │
│ 优点：                              │
│ ├─ 运行时优化                       │
│ ├─ 包体小                           │
│ └─ 完全支持反射                     │
│                                     │
│ 缺点：                              │
│ ├─ 首次执行慢                       │
│ ├─ 运行时内存大                     │
│ └─ iOS不支持                        │
└─────────────────────────────────────┘
```

### Unity中的选择

```
Unity平台选择：

iOS：
└─ 必须使用IL2CPP（AOT）
   └─ iOS禁止JIT

Android：
├─ Mono（JIT）- 开发时
└─ IL2CPP（AOT）- 发布时推荐

PC/Mac：
├─ Mono（JIT）- 开发时
└─ IL2CPP（AOT）- 可选

WebGL：
└─ 必须使用IL2CPP
```

---

## 16.6 代码优化建议

### 帮助JIT/AOT优化

```csharp
// 1. 使用sealed类
// 阻止继承，允许去虚拟化
public sealed class Player
{
    public void Update() { }  // 可以内联
}

// 2. 避免不必要的虚方法
// 不需要重写的方法不要标记virtual
public class Enemy
{
    public void Attack() { }  // 非虚，可内联
    public virtual void OnDeath() { }  // 虚，不内联
}

// 3. 使用struct代替小型class
// struct方法更容易内联
public struct DamageInfo
{
    public int damage;
    public int GetDamage() => damage;  // 容易内联
}

// 4. 避免在热路径使用反射
// 反射阻止优化
void Update()
{
    // 不好
    var method = GetType().GetMethod("DoSomething");
    method.Invoke(this, null);
    
    // 好
    DoSomething();
}

// 5. 使用泛型约束
// 帮助编译器生成更优代码
void Process<T>(T value) where T : struct, IComparable<T>
{
    // 编译器知道T是值类型，可以优化
}
```

### IL2CPP特定优化

```csharp
// 1. 避免反射创建泛型类型
// IL2CPP需要提前知道所有泛型实例化

// 不好（运行时创建）
Type listType = typeof(List<>).MakeGenericType(someType);

// 好（显式使用）
List<int> intList;
List<string> stringList;

// 2. 使用link.xml保留需要的类型
// 防止代码剥离移除反射使用的类型

// 3. 注意AOT限制
// 某些动态代码模式不支持
```

---

## 面试要点总结

### 问题82：什么是JIT编译？

**答案要点：**

1. **定义**：Just-In-Time，运行时将IL编译为机器码
2. **流程**：C# → IL → JIT → 机器码
3. **优点**：跨平台、运行时优化
4. **缺点**：首次执行慢、iOS不支持

### 问题83：什么是方法内联？有什么好处？

**答案要点：**

1. **定义**：将方法调用替换为方法体
2. **好处**：
   - 消除调用开销
   - 启用更多优化
   - 提高缓存命中
3. **代价**：代码膨胀

### 问题84：IL2CPP和Mono的区别是什么？

**答案要点：**

| 特性 | Mono | IL2CPP |
|------|------|--------|
| 编译 | JIT | AOT |
| 性能 | 一般 | 更好 |
| iOS | 受限 | 支持 |
| 反射 | 完全 | 部分限制 |

### 问题85：如何影响JIT的内联决策？

**答案要点：**

1. **方法大小**：小方法更容易内联
2. **属性**：`[MethodImpl(MethodImplOptions.AggressiveInlining)]`
3. **避免**：虚方法、递归、try-catch
4. **使用**：sealed类、struct

### 问题86：AOT和JIT的区别是什么？

**答案要点：**

| 特性 | AOT | JIT |
|------|-----|-----|
| 编译时机 | 提前 | 运行时 |
| 启动速度 | 快 | 慢 |
| 运行时优化 | 无 | 有 |
| iOS支持 | 是 | 否 |

---

[返回目录](./00_目录.md) | [上一章：性能优化](./15_性能优化.md) | [下一章：设计模式](./17_设计模式.md)