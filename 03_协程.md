# 三、协程（Coroutine）

> 本章涵盖问题：
> - 协程的底层原理是什么？
> - 协程和线程的区别是什么？
> - 协程的生命周期是怎样的？
> - 协程的性能开销有哪些？
> - 协程会不会卡主线程？

---

## 3.1 协程的本质

**协程 = C#迭代器 + Unity调度器**

### IEnumerator接口

```csharp
public interface IEnumerator
{
    object Current { get; }  // 当前yield返回的值
    bool MoveNext();         // 执行到下一个yield，返回是否还有更多
    void Reset();            // 重置迭代器（Unity不使用）
}
```

### yield关键字

| yield语句 | 作用 |
|-----------|------|
| `yield return null` | 暂停，下一帧继续 |
| `yield return new WaitForSeconds(t)` | 暂停t秒后继续 |
| `yield return new WaitForEndOfFrame()` | 等到帧末尾继续 |
| `yield return new WaitForFixedUpdate()` | 等到下一个FixedUpdate继续 |
| `yield return StartCoroutine(other)` | 等待另一个协程完成 |
| `yield return asyncOperation` | 等待异步操作完成 |
| `yield break` | 终止协程 |

---

## 3.2 编译器如何处理协程

### 原始代码

```csharp
IEnumerator MyCoroutine()
{
    Debug.Log("Step 1");
    yield return null;
    Debug.Log("Step 2");
    yield return new WaitForSeconds(1f);
    Debug.Log("Step 3");
}
```

### 编译器生成的状态机（简化）

```csharp
// 编译器自动生成的类
class <MyCoroutine>d__1 : IEnumerator
{
    private int state;      // 状态变量：记录执行到哪一步
    private object current; // 当前yield返回的值
    
    public object Current => current;
    
    public bool MoveNext()
    {
        switch (state)
        {
            case 0:  // 初始状态
                Debug.Log("Step 1");
                current = null;
                state = 1;
                return true;  // 还有更多
                
            case 1:  // 第一个yield之后
                Debug.Log("Step 2");
                current = new WaitForSeconds(1f);
                state = 2;
                return true;
                
            case 2:  // 第二个yield之后
                Debug.Log("Step 3");
                state = -1;   // 结束状态
                return false; // 没有更多了
                
            default:
                return false;
        }
    }
    
    public void Reset() { }
}
```

**关键点：**
- 每个`yield`语句对应一个状态
- `MoveNext()`根据状态执行对应代码段
- 局部变量被提升为类的字段（闭包）

---

## 3.3 Unity调度器工作原理

### 调度流程

```
每帧执行顺序：
┌─────────────────────────────────────────┐
│ 1. FixedUpdate (可能多次)               │
│    └─ 检查 WaitForFixedUpdate          │
├─────────────────────────────────────────┤
│ 2. Update                               │
│    └─ 检查 yield return null           │
│    └─ 检查 WaitForSeconds (时间到)      │
├─────────────────────────────────────────┤
│ 3. LateUpdate                           │
├─────────────────────────────────────────┤
│ 4. 渲染                                 │
├─────────────────────────────────────────┤
│ 5. WaitForEndOfFrame                    │
│    └─ 检查 WaitForEndOfFrame           │
└─────────────────────────────────────────┘
```

### Unity内部实现（伪代码）

```csharp
// Unity内部的协程管理器
class CoroutineScheduler
{
    List<CoroutineState> activeCoroutines = new List<CoroutineState>();
    
    struct CoroutineState
    {
        public IEnumerator enumerator;
        public YieldInstruction currentYield;
        public MonoBehaviour owner;
    }
    
    // 每帧调用
    void UpdateCoroutines()
    {
        for (int i = activeCoroutines.Count - 1; i >= 0; i--)
        {
            var state = activeCoroutines[i];
            
            // 检查owner是否还有效
            if (state.owner == null || !state.owner.gameObject.activeInHierarchy)
            {
                activeCoroutines.RemoveAt(i);
                continue;
            }
            
            // 检查yield条件是否满足
            if (IsYieldComplete(state.currentYield))
            {
                // 执行到下一个yield
                if (state.enumerator.MoveNext())
                {
                    state.currentYield = state.enumerator.Current as YieldInstruction;
                }
                else
                {
                    // 协程结束
                    activeCoroutines.RemoveAt(i);
                }
            }
        }
    }
    
    bool IsYieldComplete(YieldInstruction yield)
    {
        if (yield == null) return true; // yield return null
        if (yield is WaitForSeconds wfs) return wfs.IsTimeUp();
        if (yield is WaitForEndOfFrame) return isEndOfFrame;
        // ... 其他类型
        return false;
    }
}
```

---

## 3.4 协程 vs 线程

| 特性 | 协程 | 线程 |
|------|------|------|
| **执行方式** | 单线程，协作式 | 多线程，抢占式 |
| **调度者** | Unity主线程 | 操作系统 |
| **并行性** | 无真正并行 | 真正并行 |
| **切换开销** | 极低（函数调用） | 较高（上下文切换） |
| **数据安全** | 无需同步 | 需要锁/同步 |
| **Unity API** | 可以调用 | 不能调用 |
| **适用场景** | 延时、动画、异步流程 | CPU密集计算 |

### 协程不是多线程的证明

```csharp
IEnumerator TestCoroutine()
{
    Debug.Log($"协程开始 - 线程ID: {Thread.CurrentThread.ManagedThreadId}");
    yield return new WaitForSeconds(1f);
    Debug.Log($"协程继续 - 线程ID: {Thread.CurrentThread.ManagedThreadId}");
}

void Start()
{
    Debug.Log($"Start - 线程ID: {Thread.CurrentThread.ManagedThreadId}");
    StartCoroutine(TestCoroutine());
}

// 输出：所有线程ID相同，都是主线程
```

---

## 3.5 协程的生命周期

### 启动方式

```csharp
// 方式1：传入方法调用
Coroutine c1 = StartCoroutine(MyCoroutine());

// 方式2：传入方法名字符串（不推荐，有反射开销）
Coroutine c2 = StartCoroutine("MyCoroutine");

// 方式3：传入IEnumerator
IEnumerator enumerator = MyCoroutine();
Coroutine c3 = StartCoroutine(enumerator);
```

### 停止方式

```csharp
// 停止特定协程
StopCoroutine(c1);

// 通过方法名停止（只能停止用字符串启动的）
StopCoroutine("MyCoroutine");

// 停止所有协程
StopAllCoroutines();

// 协程内部自己停止
yield break;
```

### 生命周期与GameObject的关系

| 情况 | 协程状态 |
|------|----------|
| `gameObject.SetActive(false)` | **停止**，不会恢复 |
| `gameObject.SetActive(true)` | 不会自动恢复 |
| `enabled = false` | **继续运行** |
| `Destroy(gameObject)` | **停止** |
| 场景切换 | **停止**（除非DontDestroyOnLoad） |

```csharp
// 验证代码
IEnumerator TestLifecycle()
{
    while (true)
    {
        Debug.Log("协程运行中...");
        yield return new WaitForSeconds(1f);
    }
}

void Start()
{
    StartCoroutine(TestLifecycle());
}

void Update()
{
    if (Input.GetKeyDown(KeyCode.D))
        this.enabled = false;  // 协程继续运行
        
    if (Input.GetKeyDown(KeyCode.G))
        gameObject.SetActive(false);  // 协程停止
}
```

---

## 3.6 协程的性能开销

### 1. 内存分配

```csharp
// 每次StartCoroutine都会产生GC
IEnumerator BadCoroutine()
{
    while (true)
    {
        yield return new WaitForSeconds(0.1f);  // 每次new都分配内存！
    }
}

// 优化：缓存YieldInstruction
WaitForSeconds wait = new WaitForSeconds(0.1f);

IEnumerator GoodCoroutine()
{
    while (true)
    {
        yield return wait;  // 复用，无GC
    }
}
```

### 2. 常见YieldInstruction的GC情况

| YieldInstruction | 是否产生GC | 优化方法 |
|------------------|-----------|----------|
| `yield return null` | 否 | - |
| `yield return 0/1/...` | **是**（装箱） | 用null代替 |
| `new WaitForSeconds()` | **是** | 缓存复用 |
| `new WaitForEndOfFrame()` | **是** | 缓存复用 |
| `new WaitForFixedUpdate()` | **是** | 缓存复用 |
| `new WaitUntil()` | **是** | 缓存复用 |
| `new WaitWhile()` | **是** | 缓存复用 |

### 3. 优化示例

```csharp
public class CoroutineHelper
{
    // 静态缓存，全局复用
    public static readonly WaitForEndOfFrame WaitForEndOfFrame = new WaitForEndOfFrame();
    public static readonly WaitForFixedUpdate WaitForFixedUpdate = new WaitForFixedUpdate();
    
    // 缓存不同时间的WaitForSeconds
    private static Dictionary<float, WaitForSeconds> waitForSecondsCache = 
        new Dictionary<float, WaitForSeconds>();
    
    public static WaitForSeconds GetWaitForSeconds(float seconds)
    {
        if (!waitForSecondsCache.TryGetValue(seconds, out var wait))
        {
            wait = new WaitForSeconds(seconds);
            waitForSecondsCache[seconds] = wait;
        }
        return wait;
    }
}

// 使用
IEnumerator OptimizedCoroutine()
{
    while (true)
    {
        yield return CoroutineHelper.GetWaitForSeconds(0.5f);
        yield return CoroutineHelper.WaitForEndOfFrame;
    }
}
```

### 4. 状态机类的内存

```csharp
IEnumerator CoroutineWithLocals()
{
    int counter = 0;           // 被提升为字段
    string name = "test";      // 被提升为字段
    List<int> list = new();    // 被提升为字段
    
    while (counter < 100)
    {
        counter++;
        yield return null;
    }
}

// 编译器生成的类会包含这些字段
// 协程运行期间，这些对象不会被GC回收
```

---

## 3.7 协程的高级用法

### 嵌套协程

```csharp
IEnumerator OuterCoroutine()
{
    Debug.Log("外层开始");
    yield return StartCoroutine(InnerCoroutine());  // 等待内层完成
    Debug.Log("外层结束");
}

IEnumerator InnerCoroutine()
{
    Debug.Log("内层开始");
    yield return new WaitForSeconds(2f);
    Debug.Log("内层结束");
}
```

### 协程返回值（通过回调）

```csharp
IEnumerator LoadDataCoroutine(System.Action<string> onComplete)
{
    yield return new WaitForSeconds(1f);
    string result = "加载的数据";
    onComplete?.Invoke(result);
}

void Start()
{
    StartCoroutine(LoadDataCoroutine(data => {
        Debug.Log($"收到数据: {data}");
    }));
}
```

### 协程返回值（通过包装类）

```csharp
public class CoroutineResult<T>
{
    public T Value { get; set; }
    public bool IsDone { get; set; }
    public System.Exception Error { get; set; }
}

IEnumerator LoadDataCoroutine(CoroutineResult<string> result)
{
    try
    {
        yield return new WaitForSeconds(1f);
        result.Value = "加载的数据";
        result.IsDone = true;
    }
    catch (System.Exception e)
    {
        result.Error = e;
        result.IsDone = true;
    }
}

IEnumerator UseData()
{
    var result = new CoroutineResult<string>();
    yield return StartCoroutine(LoadDataCoroutine(result));
    
    if (result.Error != null)
        Debug.LogError(result.Error);
    else
        Debug.Log(result.Value);
}
```

---

## 3.8 协程会不会卡主线程

### 答案：会！

**协程本质上就是运行在主线程上的**，所以协程中的代码如果执行时间过长，一定会卡住主线程。

### 原理分析

```csharp
// 协程的执行流程
void UnityMainLoop()
{
    while (gameRunning)
    {
        // 1. 处理输入
        ProcessInput();
        
        // 2. 执行FixedUpdate（可能多次）
        while (fixedTimeAccumulator >= fixedDeltaTime)
        {
            FixedUpdate();
            fixedTimeAccumulator -= fixedDeltaTime;
        }
        
        // 3. 执行Update
        Update();
        
        // 4. 执行协程的MoveNext() ← 协程在这里执行！
        foreach (var coroutine in activeCoroutines)
        {
            if (coroutine.IsReady())
            {
                coroutine.MoveNext();  // 这里会执行协程代码
            }
        }
        
        // 5. 执行LateUpdate
        LateUpdate();
        
        // 6. 渲染
        Render();
    }
}
```

### 卡主线程的示例

```csharp
// 错误示例：这会卡死游戏！
IEnumerator BadCoroutine()
{
    // 在yield之前执行大量计算
    for (int i = 0; i < 10000000; i++)
    {
        // 复杂计算...
        float result = Mathf.Sin(i) * Mathf.Cos(i);
    }
    
    yield return null;  // 只有执行到这里才会暂停
    
    Debug.Log("完成");
}

// 错误示例：死循��没有yield
IEnumerator DeadlockCoroutine()
{
    while (true)
    {
        // 没有yield，永远不会让出控制权
        DoSomething();
    }
    // 永远执行不到这里
    yield return null;
}
```

### 为什么会卡主线程

| 关键点 | 说明 |
|--------|------|
| **单线程执行** | 协程运行在Unity主线程，不是独立线程 |
| **yield才暂停** | 只有执行到yield语句时才会暂停并让出控制权 |
| **MoveNext阻塞** | MoveNext()调用是同步的，执行完才返回 |
| **帧内执行** | 协程代码在一帧内执行，耗时过长会导致帧率下降 |

### 正确的做法

```csharp
// 方法1：分帧处理
IEnumerator ProcessLargeData(List<Data> dataList)
{
    int processedPerFrame = 100;  // 每帧处理100个
    
    for (int i = 0; i < dataList.Count; i++)
    {
        ProcessSingleData(dataList[i]);
        
        // 每处理100个，暂停一帧
        if (i % processedPerFrame == 0)
        {
            yield return null;
        }
    }
}

// 方法2：基于时间分帧
IEnumerator ProcessWithTimeSlice(List<Data> dataList)
{
    float maxTimePerFrame = 0.016f;  // 约60fps的一帧时间
    float startTime = Time.realtimeSinceStartup;
    
    foreach (var data in dataList)
    {
        ProcessSingleData(data);
        
        // 如果本帧时间用完，等待下一帧
        if (Time.realtimeSinceStartup - startTime > maxTimePerFrame)
        {
            yield return null;
            startTime = Time.realtimeSinceStartup;
        }
    }
}

// 方法3：真正的多线程（用于CPU密集型任务）
IEnumerator ProcessInBackground(byte[] data)
{
    bool isDone = false;
    byte[] result = null;
    
    // 在后台线程执行
    System.Threading.Tasks.Task.Run(() =>
    {
        result = HeavyComputation(data);
        isDone = true;
    });
    
    // 等待后台线程完成
    while (!isDone)
    {
        yield return null;
    }
    
    // 回到主线程使用结果
    UseResult(result);
}

// 方法4：使用Unity Job System（推荐）
IEnumerator ProcessWithJobs(NativeArray<float> data)
{
    var job = new MyComputeJob { Data = data };
    JobHandle handle = job.Schedule();
    
    // 等待Job完成
    while (!handle.IsCompleted)
    {
        yield return null;
    }
    
    handle.Complete();
    // 使用结果...
}
```

### 常见误区

```csharp
// 误区1：以为yield return new WaitForSeconds()期间不占用主线程
IEnumerator MisunderstandingExample()
{
    // 这1秒等待期间，协程确实不占用CPU
    yield return new WaitForSeconds(1f);
    
    // 但这里的代码仍然在主线程执行！
    for (int i = 0; i < 1000000; i++)
    {
        // 这会卡主线程
    }
}

// 误区2：以为StartCoroutine会创建新线程
void Start()
{
    // StartCoroutine不会创建新线程
    // 它只是注册一个迭代器让Unity调度
    StartCoroutine(MyCoroutine());
}
```

### 性能对比

```csharp
// 测试代码
IEnumerator PerformanceTest()
{
    System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
    
    // 测试1：一次性处理（会卡）
    sw.Start();
    for (int i = 0; i < 1000000; i++)
    {
        float x = Mathf.Sin(i);
    }
    sw.Stop();
    Debug.Log($"一次性处理: {sw.ElapsedMilliseconds}ms");  // 可能100ms+
    
    yield return null;
    
    // 测试2：分帧处理（不卡）
    sw.Restart();
    int frameCount = 0;
    for (int i = 0; i < 1000000; i++)
    {
        float x = Mathf.Sin(i);
        if (i % 10000 == 0)
        {
            frameCount++;
            yield return null;
        }
    }
    sw.Stop();
    Debug.Log($"分帧处理: {sw.ElapsedMilliseconds}ms, 用了{frameCount}帧");
}
```

---

## 面试要点总结

### 问题14：协程的底层原理是什么？

**答案要点：**
1. 协程基于C#的迭代器模式（IEnumerator接口）
2. 编译器将协程方法转换为状态机类
3. 每个yield语句对应一个状态
4. Unity调度器在每帧特定时机调用MoveNext()
5. 协程运行在主线程，不是多线程

### 问题15：协程和线程的区别是什么？

**答案要点：**
1. **执行方式**：协程是协作式单线程，线程是抢占式多线程
2. **并行性**：协程无真正并行，线程可以并行
3. **切换开销**：协程极低，线程需要上下文切换
4. **数据安全**：协程无需同步，线程需要锁
5. **Unity API**：协程可以调用，线程不能调用

### 问题16：协程的生命周期是怎样的？

**答案要点：**
1. 通过StartCoroutine启动
2. 通过StopCoroutine或yield break停止
3. GameObject.SetActive(false)会停止协程
4. MonoBehaviour.enabled = false不影响协程
5. Destroy或场景切换会停止协程

### 问题17：协程的性能开销有哪些？

**答案要点：**
1. **内存分配**：每次new YieldInstruction都产生GC
2. **状态机类**：局部变量被提升为字段，占用内存
3. **优化方法**：
   - 缓存WaitForSeconds等对象
   - 用yield return null代替yield return 0
   - 避免在协程中频繁创建对象

### 问题18：协程会不会卡主线程？

**答案要点：**
1. **会卡主线程**：协程本质上运行在主线程，不是多线程
2. **原因**：
   - 协程的MoveNext()是同步调用
   - 只有执行到yield语句才会暂停
   - yield之间的代码都在一帧内执行
3. **解决方案**：
   - 分帧处理：每处理N个数据yield一次
   - 时间切片：检测帧时间，超时则yield
   - 真正多线程：Task.Run或Job System处理CPU密集任务
4. **关键理解**：yield return WaitForSeconds等待期间不占CPU，但yield之间的代码仍在主线程执行

---

[返回目录](./00_目录.md) | [上一章：渲染与优化](./02_渲染与优化.md) | [下一章：ECS/DOTS](./04_ECS_DOTS.md)